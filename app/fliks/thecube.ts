// Full standalone HTML for The Cube game
export const getTheCubeHTML = () => {
  return "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>The Cube</title>\n  <meta name=\"viewport\" content=\"width=device-width,height=device-height,user-scalable=no,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0\">\n  <style>\n@font-face {\n  font-family: \"BungeeFont\";\n  font-weight: normal;\n  font-style: normal;\n  src: url(\"data:font/truetype;charset=utf-8;base64,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\") format(\"woff2\"), url(\"data:font/truetype;charset=utf-8;base64,d09GRgABAAAAADCIABIAAAAAbvQAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAwbAAAABwAAAAcgMaRMEdERUYAACp8AAAAHAAAAB4AJwBoR1BPUwAAKygAAAVDAAAkYl+xQ2BHU1VCAAAqmAAAAI4AAADuG+w0B09TLzIAAAIMAAAATAAAAGCWIuetY21hcAAAA3gAAADPAAABmq1lz21jdnQgAAAGvAAAAFAAAABQHj4lfmZwZ20AAARIAAABsQAAAmVTtC+nZ2FzcAAAKnQAAAAIAAAACAAAABBnbHlmAAAHwAAAHtIAADeIYFYc6GhlYWQAAAGUAAAANQAAADYSj5dVaGhlYQAAAcwAAAAgAAAAJBWYAf1obXR4AAACWAAAAR4AAAGIw8giGmxvY2EAAAcMAAAAsgAAAMYcxw9WbWF4cAAAAewAAAAgAAAAIAF/Ah5uYW1lAAAmlAAAAvEAAAZjloOeOHBvc3QAACmIAAAA7AAAAY9ePAmCcHJlcAAABfwAAAC9AAABMcb0/DZ42mNgZGBgAGJzsc274vltvjLIczCAwKVr+xJB9A2mXjEGhv+6HM3sW4BcDgYmkCgAI/EKQwAAAHjaY2BkYOAV+tHJwMApxMDw/z9HMwNQBAUkAQBo9wSpAAEAAABiAFIABQAAAAAAAgABAAIAFgAAAQAByAAAAAB42mNgZtnEOIGBlYGF1ZjlLAMDwywIzQTCaQxIQIGBgR1IMcL4KVlFCgwODAqqf9ge/nvIwMArxF6uwMA4GSTH+IXpAlgLMwB4xA5BeNotkKFLQ2EUxX++9+7nNL5kMFhFTCYxrAguiMgQ02OMsWCZ8lCZYBpiEBnzf5iCimFpmAwGgwyxTZMY1gZi0er5nu+Dw7nc79zDPTcYs4pecAsTAwjrXNsCFQclW2KnUGTbzbEevLMf7lITEnvg0D7ohDFpmFD2HDwxba80oxdqNkvZZqjbHS1bJLVzmhaxYT2qqqvZnGB9Lr2P+N6KJO6LYxuyZwPa5jTzK16hHX2Lb2i6WPWQhrXYyv46tN2z4FSPpD/I2eu1uzyXpTvxnu5K3iOhq/3XqPgsfucsT59Nv0eEsnSZV/809Dr1spv4jG8w2VOdc3Che42F0j/4EZ+JG7k+h/eYivNb+cxH8hUKn6Re7z3sEf4AOzpYcgAAeNpjYGBgZoBgGQZGBhCYAuQxgvksDBVAWopBACjCxZDAUMewgGGtApeCiIKkgqyCmoK+Qrzqn///gWoUGKrBcgwKAgoSCjIIuf+P/5/8v+L/nAdeD1wfOD1weGDxwOAB461UqF04ACMbA1wBIxOQYEJXAHQyCysbOwcnFzcPLx+/gKCQsIiomLiEpJS0jKycvIKikrKKqpq6hqaWto6unr6BoZGxiamZuYWllbWNrZ29g6OTM27rXVzd3BmoBuI8wFREZExsVDTx2gAWWiwuAHjaXVG7TltBEN0NDwOBxNggOdoUs5mQxnuhBQnE1Y1iZDuF5QhpN3KRi3EBH0CBRA3arxmgoaRImwYhF0h8Qj4hEjNriKI0Ozuzc86ZM0vKkap36WvPU+ckkMLdBs02/U5ItbMA96Tr642MtIMHWmxm9Mp1+/4LBpvRlDtqAOU9bykPGU07gVq0p/7R/AqG+/wf8zsYtDTT9NQ6CekhBOabcUuD7xnNussP+oLV4WIwMKSYpuIuP6ZS/rc052rLsLWR0byDMxH5yTRAU2ttBJr+1CHV83EUS5DLprE2mJiy/iQTwYXJdFVTtcz42sFdsrPoYIMqzYEH2MNWeQweDg8mFNK3JMosDRH2YqvECBGTHAo55dzJ/qRA+UgSxrxJSjvjhrUGxpHXwKA2T7P/PJtNbW8dwvhZHMF3vxlLOvjIhtoYEWI7YimACURCRlX5hhrPvSwG5FL7z0CUgOXxj3+dCLTu2EQ8l7V1DjFWCHp+29zyy4q7VrnOi0J3b6pqqNIpzftezr7HA54eC8NBY8Gbz/v+SoH6PCyuNGgOBEN6N3r/orXqiKu8Fz6yJ9O/sVoAAAB42kXOOw6CQBCAYRZkeYo81pIEbbeztrAQLIiJsYLEA3gCGwttrIwexQxWxnN4HnHUce3m+5OZzI21B2AnrQR7UTWMneum4LIaQFiXIJY47OsUuFxVGhhZDoacgpPlV+Opyw9shHMkWAh7RuAIa0QwETwldBBmQnDf1x4ED+FuCT7CGxK6CN//gkFAr8RYg4suG6PYICNkvFYMkdFEsYcMx4pJlt+1YNdqqoh3SRj/lz6uiPmPNQj5AnNnVq8AAAAAAAXDBcMBhwE7AVwBbwF1AX8BgwGMAZEBrAIaAdEBvAHAAcUBywHRAdUB3wFnAV8BQgFOAXgBUAFZAb4AxwGUAYUArwArAC0BtAHIAEQFEXjaY2Bg0IHCNoZXTFZM15jXsSixRLHMYLnGasU6g/UWGxObGVsI2wq2b+w+7Os4mDiCOE5wKnAu4OLgCuHaxPWMW4U7gvsITxHPI94g3jm8D/gs+Dr4XvG78M/ifycQJbBIUEgwS3CfEJ9QidALYTvhNuFrIi4ih0STRK+JSYmFiZWIbRB7IS4gniN+QfyHRIwkFxCq4YBOknGSVZKLJE9J8Uj5Se2T1pOeB4ZHALNAMRwAAHja1Xt7dBTnlWd91Q+1RKu6+q1Wd6tVXeouNUWr6S615EbowcM2xrJMNJhhOIpgcSZLfEwU4vWwDMeHJQxhGYcwWZzYYWzW4yUMh2GYqlYno0McB8chxPEyHI4XdGaJBzMej6eJJyZewmAHFXvvV/0Uwh7vf6tzqO9R3V333u8+fvfWhWGZ5QzDfsHyCGNiGpgujTCpxfkGc/xfM5rV8svFeRMLU0Yz4bYFt/MNVunW4jzBfcUpOGOCU1jOtusd5Dl9k+WRj/9qufksAz/JHIXLK5bXGAcTYR5g8mGGkTWPvQi/yMj0QtT2lMpfVJmMFvAW1QY6TNoCvE3WHJ6i6khpNk9RE4gMz/c4Xeq83MK0O96jCBlfg4kjohCNSyZnN93wOj1W3DjGChLZI7WzITYm6T+RomxQlMg2KRqV9D2SaNkmiaJ0q4jrmX8hdlzp1+HKUJrH2dfM50s0r2MolapbKdibmQazrAYzdKe0pOQ7Lmo2rqja+MmHbA2crDHACJPSGry4p0WIrLVwxcmHIjzc83sNZu5kgsxab2AjWTKqRFgeJvrfZyMs+1h5y4lb/xu2LBPZSCQ7czQbaeth11bnyMcKhrFMAR8PMg+TnzN5OGJZzSl0zLuRqbBCx8ID5uXuZnnSsmD4oQ6/oj1gLU5mBwZXdPgzBa6B3rLKIw/jLQ5uOVoCUbhF1FUp7XNEVntaTw4+cuM045WbOPV+XnWe0pb4PlL9p04Obvy3KG6r/bwaPKX1wq5wygKfmbTc73TDr9KrA68nBz//bwx8dt4kj0uLuoSfbFnid8vw3clAfxA/MXbjt/QTrbi0qL38ZLRXgB+Q6XUBvWbxWv2xHlxa8DcG8Ev4q4P4q9UfG8IlpWkFPhg/MVx+7kP4ncmR8jcfxv080Nf+p+1/Klo5pyuXh6/jACThAI+DgRmy8/5Woad/6H5nsHdJV80fGQpZrA7e3xJoFaLygmxP/8Dg0P0rhh8aeXj2R2f/qUOtBLUm293TR3rFaLyf0NkA6SMZn4Mo1VnGFyYeq0waqjOOyCQaHyRidRaNw3fEFVFpV3gNWsDTQXNEmpYkc/C90szSOowmsjO8Gu/vDZfuh98rzSyhETCt3vfC75HxS5J4Roz/Uoq+ip991bhGJdg4I0pw8xe48QvjKpLhMwxhNt1eYb5i3c4MMnuYfD96BnNjMd9vbpInh/rvaZTzIVBOrcNUzIc6cC/kbwR7G0qpfRdVd0brdhTRGLv78F73wka8CvCtvm7c6GMaZdWR0ZaA9XX3OV3ft8yzxTrlDn+O0cz94EeUnNrh1JqTuZwacmkudw78Sm+W+pGebHdcinURlHBpC+RYEibYptXr8fktbQSXDV7D5fQTuGwSJVYKtrYG9bP7/+ZHR8Q4SYBYqHsRg+FwkKT3q1MvwWpaiurvSeLKD+BeiyiwsueZ49Mv/oB7Aj/7ZVECZxQNBmNswnPgr6efn+KfwHOYoP7Jwqy5fb3hpuUs4wT/lGKWMA8zp5n8IFr3AqVwr5nhzHLejHYdMuYiGnwHgY3h7kFzMwx0X/W2X3QWHHSOxqwyFwsuBzMP7rh4rYXIhSZj1cRrC2G11Fgt5bUVsFpEV2UHMCBc+57hANp5sHEt4f9I7TzFTLYLnQmq95UZqrHW4nK6NIc5l9NWLIXZYHcuh6qNXjzTxoIX51hQz5jHp8BZOLvjIoi8kRj63UAMDY594qfXHPjl5m+MRiKj+x6/9AxJBJJyS4ucDJBRssIWA91tt+lTxoRdc+DS5n30o5svHSCJlqQcCMjJFtNqsnvzHnFoLKtvz44NiXuOcz4fRxrsPp/9d6olFYO/j8/D5Sfk65u/Lg7C5/44OzaIn/P7OWK1+/12PC/CDMOhXQM/vIzJMvklqOeyrZiXl6Caygpo7DzUc4+tSNTlKe1ejHQe2enKm/sW51Ar0eR7DW00NNFQQhh9KBDDwo01VV5n9XMyKann8IGJ5dmT54hKlfFCOhRKR3B6OB0Op4mYFCA+7sON1I/yM2dePkM2Hd5/eF74qyMb90yK0vtSNBaQAx2i9CYq7FCgI5EgQSkqxv9Bin7+8E9PUz6fYF9jH6NxM8PUBngeVQujIf6btDUwGNo5I7RzRc05ZzR8km3rgVDXVo1+taGOPm/j7TGTy/pFsAKBoXEYnuLkinkng5J1NoIDaMmUgm0vCEVQqsICrakRXnt84zQRJtDIhtKimB6i5qZfntZNp08Wo9JNSUxnb13IZqJomVfh2WPwbHvts20XtQA82xbAZ9t4eDZTfrafumxDN1FzDcfdTtGKAJo7JkqDaTGaGaTGT4Tpaf3ylyVx3XUpmu4xydm0CAREiydv9U1dFeHZT5KQZQ3IeQEzn6G6Qy9ETSIVBYeD4cEwu8DvOWxgXHyUGpcLXP4A8VtM8R5qRaZYjy9CfNYGi99ndRBrXJoHhpUiXWSQxJ728Su5RJKIKVtb9wdK0JYggWTcOcz7Ff3MFdEsv5rsCDz37YCUPCWbxcv6z03rROUdxen7E5JRBEHR/+5P/M7udxTRprwvJdq+EZ4nE0G/LDeFvhHplN5XDLvYz+y0rLIsZURmlFGFlOpTNLOtqHKZvEBjgBAC2zALODU3ouvvSKmRi6olo7WA62/O5FsieK/FDR+LtOA0Ak5fixn6RP22k0oeJF2xGyc9/3jWCUq2H5R+BMxBipIRahd5wIeSqOclkd1clESylu4eFSVY6EdxQdaKlPYttxX2JVZhQkwXozanCh4zYwPn2JrSzHaw4zD1po1exmGWS4PWVlHEMlStKkOmpx8D8paoRA5J4pG9h/BZ+4Lht6XoSZKiVOx4/ruiNCqJbcFI1JDfKMuZmkwFsDc/0oBPNp7Op8pGNQsXj0J8iqHZzkBEZtcSF/3lX1PkCzwBaESeHBBV8s00HjcXK5OSHc9iynkHU/icEh/w2xul6Ery3+n0PxgAmzBNt1ewpyHuOxjG7x4gtWbP3QBkAUFTMuMEwqQ0YX0Rv/3RBjBJwLRbb1+xrLNcYbygNYsYMHUgLtBUzFvRhbbPK1IlAT/gA//i47UQWIHdVUSd0EI+sAantRxqBtia6NHF1oePrb1PX3/55d8+nc0+ff1HL19/upec69u0aXHflzb1kV3syfGDE/39E99dP3Pf+MHHBwYeP3g00dubYCWpt1cyzmYjw5h3gI22QWaVD1ERNhUBteQ5JLShCQiNpFTLRc3tLebdFlRedwvoscWNUwuDaMbSBNrcbgiYuhBnCfUZoq7ikfhGUXr3ZRQTCwryU5rcbAV0AV6DPY7OAzdcYhwnqDdAWwFoSzKdTF5G2qKAu7xIGNcIhHWltBQGIS4KArOGKTBCefXGBgggIwPtVGNMg4UDJFQNTPHR1Jqt9xK34GuJ6MtQ29jPnzh5/IBejPjY+yktGSCObNj63Udznt+3tQsRnyhdk8S/+d6rB/9Hcq3NK8ii9IFB6xeA1teA1h4mzeS7yxixA2kNm4oFT3N3RzPETiuQ3ZvS7qGxsxnQ3YIaNAfEVog2TG0OJgw0h9tfADGyGBb1w0jsNJ3uotLtO3Yku+xbW14/PbPNAG+xQG8gSvFtrCWC8RHCw6E9W0eeCPH/bc/ZQz+gdrUT4n8EeBCYISbfimCMXhCiqU6FjkSNUrVtBLVt5LUwoKrmDCqxJiJL5lZgyZ6rM2gIX7Osjvq0neCj+oHY0I9h0kcN7zQ4ryNnTrDH2HO4njknxNitOPv4PHVp9iOGzoL9my8AnQlGZvJSWdaekqyJOj+lyUhN2Ox0Tdqb2yIApu+Uci38EAVvvVdgnYG2SItuxueankDd0D0kcOTU9NTMfwJPARL1t6wKgDqwOn4EpLn78F/o7zw/JZZsX6ZyTDGPlmoJsYYiFaDWjNqwIGxGbbAAsQupPKMgTz6Tj1JEEEVEEOW1TiMh19IwdoKO55s9oOQ5tcUJMgb9WQDCdpaEnSC1gAucVTsua10G5RtdBiAIMk1LDDuHs+mdo8RzVtn9z+rL1/Yo5Fx67Vg6PbY2TXawL568KkofSmLqwSTHn/zB6fHnHl+8+PHndgiyLGyLzJ8fwbMYgbM4CLxG0X94UF08ZZ3R2tF7iCnVf1HjwXvwfmSOt4H38PM49WMU7MCTaseCiSNXjob0KDjWQSoKA1Y9SLIwhTBompJEaWTb6LOgMgVjemQGNMa8kzqQmY83/Nd1fYGkfpAqzVeN1RTNSUzMBjibVeCXRbDTQchI8hE8HckK8QNJXmwtFrJdkWY4nay5SJO4+Re1VmcxP78VSZ6PJGOq1joffI7LB05ay3bB1GeuR8CG165a7Fwn4a5bbXhqbHl3dvv57x4895+7e5aNPbV4//WpqRv7F5PT905MLFs2MXGvIq9ZK0lr18jkvp/tf94NqHfr8B+tTiZXb30QTdn1wv6frdq1XlHW73pBmC+3b47IcoRM43mtwynWWjaAjXuAf9TN+5g8j9z7TaW4tAC4j8R4K3AfKelm8KLamdHsgBiDdhRAEEAMKiSjxSJwZiGD6UqMsiZIxV8BZxAs2+P1TG9Qvv4u1bWL+mU9QY9oB6jh1z6nv/93oH5jazMZUEHTjtPjz27u69v87PjMBtTD34AeDic55w+vICfbkCdaA6NYwNJEa2BKFQ0AsAH/WiyhbTCtEg4AoF1GBMKciCBAPgEh3A0tsHo9dEC6EHcBXSFAv313Ii/0UQLSl6T0hSv0xTKFuEFf16fDsLsQWwfLammeC6Kx35xFO2EOM1vMumUEMAFDFRoQOD4B42epoIBLLDwc3r3DRKuSMwUPx3nYYRo1r+/YzX7nwHM7O962CZL+oSRZD5l5t8tpfsEqSfpvIKe9HNsJMtrPXLOsMr9Jz67VQIY24+Rs9OTK9cdsXT4Zd85aAzo2J/HBv8Okr2ZOcldxehWEwH6ziNNihccpZovFZfCIIi5BBuQJ40KlaGKxxqfAyQ97HA7PTIFGA/uO3bt33AKPP0UcUrzhBQgywNohYI1wkmB7O/ZfngPeY5dt7agHY+Af36H4qou5n8kvQP0U7aVYEEIHmaLJgjOjdYKP7KSZQif4SCxlaJ1gY3lf0JNDPxMSweC4XL1AkEIJcqUazDMbTEPaxn77zJXj35q5IIlW2QoW92ykJRSceUMSD8NiK40Fe0sO9Icnpo8/4xk2h5GdhDlnDkfCIfF31+qqzyyz/fZ91ietT4EPfYDZy6h9qULG0G9XqrCMlmoKbcbGfalCwKjjSKmCle4RdSWF6EkHrVQnec1L5MKQUbcZ4rXlsGozVm08akHBTj+pPQgyWT4EMpEyVoyEbU4sjwkurae3ApdJh5IxUxUFn1sT571OCpu7wBFz6Kra2Bol6ugitErhRBe1fdkxIv/zu0Q+tlT8wvf360+dO3jwHDkbbF2VSm+/dPTopafS6acuHSW7pQhg/+3v6v/r2DL2W+HE3idzAukzrdhycvfKlbtPbpl5f/zg5v4ju8nTe460BmeyX/ocKyz9ykgyOfKVpbeOLv3yiNwmLZLaHtj1QzIO2cTpVNDwHRPgozdR/CADBqYRSvUodMzb2NKl0BqN2MBRtzaADi2gICLIF9UgrYhheUFLInwIQmyKiqg+NkAQqmRg5J7eUj7jdxvGXIJlpRkRTF1Yu7I2TEidk3YFMwbFPpmIg578IhHXvw2K8CYkoxfIkg02t12xu20r2VD/XzxGzouCIOqpx14cmPkn6tvb9H9EB3mS9LqcTpcRg/cBf1uBPx/Tzsxn1hu4QfNbinkLWsV8S7EgtHsswJyAMVimzPldRVXI5P0UIfnBQFQ/rwWBRd5Z1BbAGPQDf7GcyhvoSGgvQdFe55zomVSgoLMUnWSyDyxl3+uvLu7fteO1N25BuknOkiYJ/vQbJ3A4sdICDvTgixvXbG61P/+dl48fBh+TSKxKAIJNJGBm+JatYPPHgT8akYw3SaYy+msqfloFaDaaQwhd1dT2+NabhCH/hxrjHw4O9A+RP6fz5tvMTfIS+9SFczSRUhS9RUmJEnzwLOoUynwnrXkFmIVM3o5U8Y0liQcQNbdSqngEorzmAYECxkcBV4KQUQjCAE+UcpEIJZYnzM2bt5mZEZDX+evpVCp9ncrp7IWZnRfOimRDWiEfKilDNkCHeRroENEbCkhFS2NZNo3FAucXEBlz1kqC3OIySihUUi0oqVDGqKWUCii9d+D42bNoHMg0/YDGqTfIfiquLWyWxqqVkB9ZaFSExO4FmiGppaSuQm+e+u97jfzYuFSgvJ8LIcF+k5EoI8HcLIJL1LZ/IrXOKqHfooTeIH9I044/B2JfqxAJ7vdCVLoBidJmI+8EXbP0A30dzGoG0gfUNcyFovhwT6BRrlG72Fxq56S+V2uDs47D6AUjVZupY7Xn7qKMs/I5QyNZhkaRNYMDqdQZwBwD9J3ldkMpd4AalJTSp6TJEK3s7KGaWZKxZTfViQcMnVB9Ch2N1JMzUs9CY4jqRqO9ohthfJmZUcO81gqJaFNGc3PFWVrhdQp3Zp9VYWMKStaUUlEqaP1YncD1ZeRHNSnoz/RFhtw3g15sqtNjs6kIRlypm6i+DCXTAhrhKeZbLOUSIOhv3kKrgFg3wepr7C6lE6PmW1s/2RyV3ngDJWv6El7PnMHrrWcBjYKds2qphAKXmVXU9I061urbVwDPYTxZXvJH9nnFvD2MNNgtjcZLVnqppPcOmt47MIJ4aG6vORpBM8K5mmIdreNXy/iVCtVqEStj0e7xteB/yBJJzO6+Wsj/y26F7CIUIH6MRSgTLVrcaioVpsp68BTQOZ95hMl3oh60KnSs04NyQOgwDr+Dx4Kl5ueMKNDWAWQ25VS/U3O6MeyZOyECNkZzuVqdUCrlvNrwR4NBnWqMvsll4mSx2MKdf2KvUaEQ2vXf1GtIgrwVi4iCLlq/s33mx1RN9gsxXa71IRYF+AowixkIYCD/RrDRRpoON3IlGy3x1lpbXmkChtyOei88l0qXFTkAYydFv7+ukHeryRD6zPZaeqzoM9LMMJNPoZxDCh0NOXvKcs5QWmRnUZV5dF/44kBTYGyXQaY2FxVvCqZ2oVa8iCkwRSljjKqAS+90U6SG7pWC7Jpqctjddq7pb12yQOirXP2nUnSbqxuSFMW1DWR8rsRPWNDzCCTIiBAuGyV7/m2xLRJ9eyZVqg+jvLfRmgT47Hbkz6vQ0eCvucyfSPkLAX8hXguAB2nMaC5AE7QkYW5HvQmWGcPqvH92Iauf1HByQeoNYjwkCtWKs+BKXjJGSnkgoi8ihaoruUWOzowhwUa9aOIz1oq5/5da8b6Pf/zKzX333LPv5iuv/G5fLznfPzHRP/Dlif5/T63YwBBJkKsHouEgk3ehROmFgog2W7HQ7HUhbGu2VqIhBzR7MypHBYx+pS4Olt8tlXFnHRJ7gvj/51n96vuGtZGzU33x2OIpKsx/yOsf59/SjyO0/NWA9Lg0wFA5rqByDIEHGWEM8Unz4Pkprb25AiQxaEDEEEtSRKcRZsBpBHKq6FStOdUOEqW63e5F4bbmcrNlW32X3kXuIuPYukPbDIfx6+/VyPk77F9W5PwHI7v/40p+C6r7FnH6TOKeexJsypC2IeuDNL4ksYZIo6K7FBWpuJPWYiHUIaC4Q1ZaDC8z15EBJ4++JYwoGVj1I0oGVlPoJ8PAamcFJXeE5kbJczrF+uM59u4JZXACveJPIJ7L+hWDXXLuYDYWyx6k5/TjZ9ev2QZQeadO31uRXFLWJ2BmSvQm7kv0Ym8FxNErdTV+rOW6aXZsqqnxhyDN1po77tL8UPu6uabnQZzd6vCPP2MH6rsc3qmUyKv9DSd+OKux4cRJ6ldycCZW6sfrtJ8iLD9EfHuG+m8vaD2k8pwXz4ADkJX3cjj1Yu0wOEdJo7YsnhMlc46S+GaUljch0SpXNuFyy01rEP9K6dkFfuNJGtcX18R1s9EGVl+u91Tjuetu8ZwmGnPE811GFB94bHM/zHol8Z59N1555cY3e8ku0w3qytbRgH6kPqCTSh6rMP3G2RoXSmCoTGC3QaCXEoipqwCAI0s9MEQZlZ/1MqE2uNRRWu2x6zJNAAC9T0rYbBusTt7PO60bbDYgfakUtfIB1+ucIs38SlK4110B3moaY8NGZuCZ79OveByclwj+Ti9L3fjMO+nl/cuT+jwpHJbIb5OwMGLodoihWOPPYQxV0DqjCh0N9nxl9hbVxnMXpqkQYPpgdIH8tfhCGkMVDDXzc3Wsuo0uEn9tNaeGRyM9r1lvN16jbOWz0hop6/wjWKYlsSn4xSZJ0D8QsrZxq9vusrtBFl0AYYRU0xeDTexGk5+yyRFWDIdFXWc/pKf47tKvDOtXI3K4nYygSPR8pC0hkNbhLQbvFuyf+BwzzuQfRt57FDrSGroaU+hI1FFa24Sg+iDkcM6M+iCvLYIoK2Q0BTYSGe33QA4Pou+15DRlEYxdII3mh0EagaVlSx8kUp2N+yLE0ABsE6i1fQfxV60e3RT2CKCUHISr7G8XkkeOpCKGrMzcuiY/H+C99jHOIsbJPVK0HW+3geX9XIqaHevsXj7Me5rHODMY5OvgJy6Njw9dvjy4ftyosHq6PF/jXS7+a56kl3alHIL7V96C+5doAxned/G8C+//ooK/xkB+Kyj+gig1H+U2/067yNQqDrULZ3EyLrTYwPWDsSRTWtxL0Rjoz/w5DKVWTNlaHaq+VAH5jJUlsb7J5/Tw/qb1yCpqjpDUXzdesOhnUhHTNbKXeiUVWHoGWXoGWCKr6N7W8fWD+jr9FnXxVnJ4cNzgEwZzkfqnNibfhv7JZyq9Z7FiQhpN0beGpYoUEWpfGiOhNQn8eKCVfKivpM7vBICpoB4jV2nyY8NXtC6pL8yOldIf/VxicWjmVDkBqvbfBBiZKSHsghu8sVmGBAIL7zhzZWg1yc3QBBi7YZx3y8I2QkgJ48OfeYZmue9I4jorraKih7bR3huxvn+g1DXkd/voL0icWcIkKWK+ARN9GibWdKV9QKrp2wlAXCzRDAluieyCiw5Vgi25SvtO/bv3SgX4wAEKlcM09X7HaNox3aQNO1Hpo70V3VxFxiyy5WWsiwdJ2QUB0bTM3EUa4tTpSLFofO1bsZ3Pffu5HdJbtghW+RPmF82c28PBkMB1hBwz2Xfs2UNr5SwLD1/lcbKs0zOj0nWpt+Z20rKKefMTekP8s0B3Xbl/b11rCPYMWFnT8QbsNfljRrWnan8L+/9uLji1nXb62rs4lTulWVs+sqjmUydv9p/ahm22qpmftJitbsg2+clmzu4GtGW21vTRwh52zk5amq0cbRj8vtliL83rel/LGAQhyijAVDR/caZHEq1HT4sd5rXmiPRTMYYjpTsB570CzruHSTHYIqAqF1Vzhia5nky+Q0EA0dEMeE7OYPeA1qHQt2+lh83uGjP8IX1dg36gvgOvHUy/iySWLJ0mwjqUnpwWpexyzm7nlmclMY2Jq7ROvzy9dAl7csXKUQ9xVnrLrvUvstlZu4Ozs8223MCvyp1mU6TJ8wjysRt0finVeT9T7qhD1I//5j7P3bRcINJmU7Gui4Yp2cH2WrnYLqr+jLYQ5CJl8raFtIstYtRRUC4LbdQX1nSzoTFQJ2hEBAPA1ja3lV71VJvc5pQHEUAeS5dM65fXGdaTyf4KhNHM2jkOLrZF/dcqDXD6B57RlStW/p5Xv4GdcFTPWY9llekCE2P+CXvItIbGohpov+hUWxWNs2HFkKjxlCYZanpDO3WCqmlrl9rQpbbyWnPDR5zawGttDR/BMGlraHbLk4302kSv8+jVjle1jZ8MtrXCMkSvYbzm4StVPVYbc1glmQfZTi4P93ErlFODOWaosbFpXijcZrMHa7rB7cZmg83e3Bq8o9tbEwIg9Y6c1sCVWxJQKQdYX4RtA9H39hh5BcfGU2wX6GWDNb4/GRl57NGvrM0MbtiyenQw25MOjjz+6FfXpEZHJ9auzik97Lq/z3Y1BVtYvtlq4+Y1+NyckHwjm4Qtk9NunWe32bwurq2uv4z5DI1k//98bz/Lge58lv65Oh95R/8c/J5t12f9vYYNNAV5ca5+PPY19iWI8yF8s0BLtc2Vd93Oapehz2jI89V2GbpLpZWq41JqXmcf2fuC8SI7dLn8CttkJzufP0jfXkdaAcfp59FTzEGD1movVl+7f1Kno/uzdjqaV1bfo0fLlOC7XvY1S5jSkGOWGVSoglIWRiKDYbxHQZGoXZlSalASB9Z1wkQuKAZhfZ8unNgn3Ryro1eMg+RE9s/+veKU5hLxXfmjgu7JgKzVhFLuckhX+Cv1NRjNYuXehr5PF3zsk24ibD0kResYYv9s1lHB5txHJc11fIwJe0lsW2hfKf5/hZFSN0logaJgS4nm6chkarpMF85ijwf2AsYqQMulhYTBbHrORpPYp6zrGk/Y94Boyqv+KHD6nli9J9Y2okh3mRtYC/9TBvYomrBHkcGUg14IW7oQ1Ux5MnnxZXtp0CyU/LRTcOKXP+6H7/xffa44cwAAeNqllM1uEzEQx2fT9CPqx4GeQEj4gCoQrZNWVFWTXlpVQa0i9SNVL5ycrJPdZrMb2U7yALwA4sKJA0/BBY7cOPAsSHDmb6/bNKjqgWa19s/jmfHMeDZE9DS4pIDy3yq98BzQHB17LtA8Cc8z9Jg+eS5C57vnWdoJ9jzP0UrwwfM8vQx+e16g1cIbzyXwO8+L9KjwzfMS+I/nZXpffOV5hZ4Uf+H0oFjCas1FYjmAxZ7nArTOPM/QFsWei9D54nmWUvrheQ65G8/zdB589rxAa4Vnnkvgt54X6Xnho+cl8E/PywGbKXleodfFr3RJkhQZRNBG5RJibjROmoItaaJLqUzcFgkTiZEqFUZCeEBD6HShIbEYpl2J+RyLLjYSGCssZXeYCMAmcaq4p0YhXWGPgW672PjXdpNXKpVaeKVYLfe+cePtzqPzXDRyybDJpo48peaNpEYRNAwytnqjGzmnHdxFjfo4vgdfVqcDaQKPLexw2nbvrvNpa6LjLGV5mKdNC7UoM+0sHVnmO1u1vujJzHR4Ere2+Dbf3q1U6P6k78uUIRDtroghNIU5hLTvDHuQZQiX0QXSs7p1l54BWR8KMoGZXx/BYs0EM0qEsi9Uj2UddhFJVs9Sww6GSoohVA9hM8KpIbwcO3+2JSKMtsDnkGjbHodiFIfsOENjRCJl55nWD7ONoGloQFUq4xm7h/u+4e7i+lAyZlAtl8fjMUeT8HbWf4ChrVpe3Undmq6iBi6Eq991/RP3uUhoaYw2P3tHoWs/5nKUzvqIGphPEI50OU88N6Y8rENyV/Pal92KbPrcSTeM8MaugVoY7c4YaxtH3it12sffDXP1r2KeLpKGTwX9AWQaJ2rniyMOhb4rI/464qWLCA3juqOZdcxYKNdBSdyWqZYhG6ahVMygg5pHDXYykGmu3MgV1tnkc9nkzDnztq4RRyJORCuRbBybCH1Z3z9jwlSZvyrdVvHAaK7jhGeqWz6pN+j/0rjH4V9fXDYhAAAAeNp9zEdOw2AUReHzUuzE6ZXee//txCm0YIKyDCAISCIhhEAZsCZm1O0h5DfmTj7pDg4R/t8NSESiRIkRx8ImQRKHFGkyZMmRp0CREmUqVJlgkimmmWGWOeZZYJEllllhlTXW2WCTLbbZYZc99jnA4OJRo45PgyYt2hxyxDEnnNLhjIBzulxyxTV9iUlcLLElIUlxJCVpyUhWcpKXghSlxDsffPPDJ1+8SVkqUrUGD69PQzfEs8ePI2MCo1786RljVFf11JpaV321oTbVltpWg1BXu67r3I8G4+e72/7LMLy8Xqgf6ve6v1wlP+4AAQAB//8AD3jaY2BkYGDgAWIxIGZiYATCRCBmAfMYAAfJAJB42n2NvQrCQBCEv7tICotDNEgQi7yBjS8gylWKIHkANZZHAuL7x8nlgp0s+zczO4sB5nju2JM/17jw+LRsmAmn7zGKBfZ4qCvK2/VSaZvwoVvJDDZ0TcB171dLERFiFUOui1ybFbNPk+dJFhXyZq1/o3oXL8fpxxeUyXPKTHWpdOnP4GlYsf3PfQGAahI0AAB42s1aO2wbRxAdkZatMJIo0bQlW7Kpnx1KkBM4TpEigRPEMFzkAxgqglguUgQIYMMAgyAIECCdazepWAYug0NK9qxZb83+ilRXcvN2bsnbO96X3jV8izvud3Z2dv4SLRFRg76gH6j24OHXZ7T+/MdfX9AuXUA/SUk1/CzRBtW++vJsjzYef/cNvsZI7dlPv7yg9d+e4dvmniX+EsYvqnVca9NpWGv+vvEAoy1a4VmraqYUvKqD0W9Vf7Pb/JRO6EOM+FJg1MkjA1UcwR6j+NJ3AtsH3r4jvH1dAkd4O8M82sUJTdxR/J7sxyjv2+RwV1SeDFKpJPg7lD2uDdV3EdhJvJUO0GUoz2ewRXV62aZwDHY/yYNupMgBzKE7qTTpHdXt7FftLqtwI+R9OKVNmfuQffmy7I1NgogKU36c6pjZrowrbEgQtVVL3VSch7NtmKnH4xp9fkWZe9GYBmVvr8rthDQJYc/TRL7ktqaJeZ+qVUQTDU1Ed5qvJ02Pw+TdPDsP2CKDM8bzuCRprmcGcVzkI+P29F3OfofSy6BJENlwQ94Svg7z0riCPNjXmg3+titLscY61yuMYFfyHmVHeikykSEtk2ASFMn8vKTb1/zzkKcU0hwipta5WL71Sn8mNRbsZfH6kvqkiv527GW68raKrM27eooiPRmTzPY7FKe5hO078zZrKC2UJh2i1NGqc/uI2zfpPkpHxeboO8TvvxzNr9IBdRFVf0YP6Qzx/nP6E+2/6G/M2OEY/CpoUac11LfAiR28NdQC1Hz0b+F7HW+H56raBV4R9o/pgHtaWLWj1+zjXcYcf7ZWzbmP9XVqY17YKxj2gGu7DHsVeF8Gn1yhq7RN1+g67dAu7eNUtcs/q7Ns/tf6hz6hU/a8hBOf2DfusG8RrgcLNkrwiGUOtIlvJm8PXfC38qNxn30unmmNy3v5tm2J4W26i5I8+Rg79GxbNPkacEf5cBfPbbjis6x7t0f/MNKy4ZNpL8smZok8mRER2M9tCaaDsJNlfdveyyL0gKSN0rzlLE+aCzRRkY4GVBHFYYl7U1HiOH6TrE9ew+pR6Jkv7p2lx6tVtKF9uHLAenyYBzcjZhFykGGLE1mqGDXHKfcm1F1Xo2+GjIjq1ob5IRtfP641NJ8NplopB5seLOMosZMfSXNijDOlk9FkVOTHyHvyXP4RZSHU7Cks2UA5jnnNnspATF5NXjGVz+3FE/Nnz49Zi7gxGcUbNB9n5EKHRj4lMHNn4DKRKseeomw+n837eXF+SBspb52AwSNg10uVNy/iqmScxhzjFd1dGSxMbtfyPXbzl7uCHMYoO8+Xxo9VaL2gDxZk5LGq64dZLqdwzxHHRf2cPG6SGyMdMs6L7kN7mE2fOUsRyc4oL+uU5u9oiCIlR1uYr2Y96SUk259FGb2MNT3Wez1T98e5OMy7vonNSIcdxlOF/C2KOdSWN/cm8VVV+5rid4kCe+WX0xRxblVcqPRk+XgobR+TX5nP+ul8VpEGIkOf+TYydkYmOnCTxXQSHS9RnZ7QOmp3Z3139cgdOqYTvGtoLdMmNbl/ld4P/3eFnzv6N8wn7XJGaQvtbTrgvJJ6dukG3pvUoT30HtIR3aLb1OU8W9XnhP9v5SN+Q9xvoHeTx9Zon2uH2H2dLgGnS9iP6AO8Xeyqnts4zy0NS51aYahOs6L7Vjh/ujzbb0W/W9jtPWrg7BeB9RX0XKuMe5hR3OC3BjrWURRllzXsGk7QAjZt0LAB+Dto75H6b6AjnHqTTnHmbfqYPgc1VQayS9/TUzr+H7peH0IAAAAAAQAAAADV7UW4AAAAANLWvmEAAAAA2AKNFg==\") format(\"woff\");\n}\n*, *:before, *:after {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n  box-sizing: border-box;\n  cursor: inherit;\n  margin: 0;\n  padding: 0;\n  outline: none;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: inherit;\n  font-style: inherit;\n  text-transform: uppercase;\n}\n*:focus {\n  outline: none;\n}\n\nhtml {\n  -webkit-tap-highlight-color: transparent;\n  -webkit-text-size-adjust: 100%;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  -ms-text-size-adjust: 100%;\n  -webkit-text-size-adjust: 100%;\n  overflow: hidden;\n  height: 100%;\n}\n\nbody {\n  font-family: \"BungeeFont\", sans-serif;\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  cursor: default;\n  overflow: hidden;\n  height: 100%;\n  font-size: 5rem;\n}\n\n.icon {\n  display: inline-block;\n  font-size: inherit;\n  overflow: visible;\n  vertical-align: -0.125em;\n  preserveAspectRatio: none;\n}\n\n.range {\n  position: relative;\n  width: 14em;\n  z-index: 1;\n  opacity: 0;\n}\n.range:not(:last-child) {\n  margin-bottom: 2em;\n}\n.range__label {\n  position: relative;\n  font-size: 0.9em;\n  line-height: 0.75em;\n  padding-bottom: 0.5em;\n  z-index: 2;\n}\n.range__track {\n  position: relative;\n  height: 1em;\n  margin-left: 0.5em;\n  margin-right: 0.5em;\n  z-index: 3;\n}\n.range__track-line {\n  position: absolute;\n  background: rgba(0, 0, 0, 0.2);\n  height: 2px;\n  top: 50%;\n  margin-top: -1px;\n  left: -0.5em;\n  right: -0.5em;\n  transform-origin: left center;\n}\n.range__handle {\n  position: absolute;\n  width: 0;\n  height: 0;\n  top: 50%;\n  left: 0;\n  cursor: pointer;\n  z-index: 1;\n}\n.range__handle div {\n  transition: background 500ms ease;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 0.9em;\n  height: 0.9em;\n  border-radius: 0.2em;\n  margin-left: -0.45em;\n  margin-top: -0.45em;\n  background: #41aac8;\n  border-bottom: 2px solid rgba(0, 0, 0, 0.2);\n}\n.range.is-active .range__handle div {\n  transform: scale(1.25);\n}\n.range__handle:after {\n  content: \"\";\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 3em;\n  height: 3em;\n  margin-left: -1.5em;\n  margin-top: -1.5em;\n}\n.range__list {\n  display: flex;\n  flex-flow: row nowrap;\n  justify-content: space-between;\n  position: relative;\n  padding-top: 0.5em;\n  font-size: 0.55em;\n  color: rgba(0, 0, 0, 0.5);\n  z-index: 1;\n}\n.range--type-color:not(:last-child) {\n  margin-bottom: 1em;\n}\n.range--type-color .range__list {\n  display: none;\n}\n.range--type-color .range__handle > div {\n  background: currentColor !important;\n}\n.range--type-color .range__track-line {\n  background: transparent;\n}\n.range--type-color .range__track-line:after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: \"\";\n  opacity: 0.5;\n}\n.range--color-hue .range__handle {\n  color: red;\n}\n.range--color-hue .range__track {\n  color: red;\n}\n.range--color-hue .range__track-line:after {\n  background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red);\n}\n.range--color-saturation .range__handle {\n  color: red;\n}\n.range--color-saturation .range__track {\n  color: red;\n}\n.range--color-saturation .range__track-line:after {\n  background: linear-gradient(to right, gray, currentColor);\n}\n.range--color-lightness .range__handle {\n  color: red;\n}\n.range--color-lightness .range__track {\n  color: red;\n}\n.range--color-lightness .range__track-line:after {\n  background: linear-gradient(to right, black, currentColor, white);\n}\n\n.stats {\n  position: relative;\n  width: 14em;\n  z-index: 1;\n  display: flex;\n  justify-content: space-between;\n  opacity: 0;\n}\n.stats:not(:last-child) {\n  margin-bottom: 1.5em;\n}\n.stats > i {\n  display: block;\n  color: rgba(0, 0, 0, 0.5);\n  font-size: 0.9em;\n}\n.stats > b {\n  display: block;\n  font-size: 0.9em;\n}\n.stats > b > i {\n  font-size: 0.75em;\n}\n.stats[name=worst-time] {\n  display: none;\n}\n\n.text {\n  position: absolute;\n  left: 0;\n  right: 0;\n  text-align: center;\n  line-height: 0.75;\n  perspective: 100rem;\n  opacity: 0;\n}\n.text i {\n  display: inline-block;\n  opacity: 0;\n  white-space: pre-wrap;\n}\n.text--title {\n  bottom: 75%;\n  font-size: 4.4em;\n  height: 1.2em;\n}\n.text--title span {\n  display: block;\n}\n.text--title span:first-child {\n  font-size: 0.5em;\n  margin-bottom: 0.2em;\n}\n.text--note {\n  top: 87%;\n  font-size: 1em;\n}\n.text--timer {\n  bottom: 78%;\n  font-size: 3.5em;\n  line-height: 1;\n}\n.text--complete, .text--best-time {\n  font-size: 1.5em;\n  top: 83%;\n  line-height: 1em;\n}\n\n.btn {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  background-color: transparent;\n  border-radius: 0;\n  border-width: 0;\n  position: absolute;\n  pointer-events: none;\n  font-size: 1.2em;\n  color: rgba(0, 0, 0, 0.25);\n  opacity: 0;\n}\n.btn:after {\n  position: absolute;\n  content: \"\";\n  width: 3em;\n  height: 3em;\n  left: 50%;\n  top: 50%;\n  margin-left: -1.5em;\n  margin-top: -1.5em;\n  border-radius: 100%;\n}\n.btn--bl {\n  top: 1.5em;\n  left: 0.8em;\n}\n.btn--br {\n  top: 1.5em;\n  right: 0.8em;\n}\n.btn--bc {\n  top: 1.5em;\n  left: calc(50% - 0.5em);\n}\n.btn svg {\n  display: block;\n}\n.btn--cancel {\n  display: none !important;\n}\n\n.ui {\n  pointer-events: none;\n  color: #070d15;\n}\n.ui, .ui__background, .ui__game, .ui__texts, .ui__prefs, .ui__theme, .ui__stats, .ui__buttons {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.ui__background {\n  z-index: 1;\n  transition: background 500ms ease;\n  background: #d1d5db;\n}\n.ui__background:after {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  content: \"\";\n  background-image: linear-gradient(to bottom, white 50%, rgba(255, 255, 255, 0) 100%);\n}\n.ui__game {\n  pointer-events: all;\n  z-index: 2;\n}\n.ui__game canvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n.ui__texts {\n  z-index: 3;\n}\n.ui__prefs, .ui__stats, .ui__theme {\n  display: flex;\n  flex-flow: column nowrap;\n  justify-content: center;\n  align-items: center;\n  overflow: hidden;\n  z-index: 4;\n}\n.ui__theme {\n  padding-top: 15em;\n}\n.ui__buttons {\n  z-index: 5;\n}\n  </style>\n</head>\n<body>\n<!-- PWA: https://bsehovac.github.io/the-cube/ -->\n\n<div class=\"ui\">\n\n  <div class=\"ui__background\"></div>\n\n  <div class=\"ui__game\"></div>\n\n  <div class=\"ui__texts\">\n    <h1 class=\"text text--title\">\n      <span>THE</span>\n      <span>CUBE</span>\n    </h1>\n    <div class=\"text text--note\">\n      Double tap to start\n    </div>\n    <div class=\"text text--timer\">\n      0:00\n    </div>\n    <div class=\"text text--complete\">\n      <span>Complete!</span>\n    </div>\n    <div class=\"text text--best-time\">\n      <icon trophy></icon>\n      <span>Best Time!</span>\n    </div>\n  </div>\n\n  <div class=\"ui__prefs\">\n    <range name=\"size\" title=\"Cube Size\" list=\"2,3,4,5\"></range>\n    <range name=\"flip\" title=\"Flip Type\" list=\"Swift&nbsp;,Smooth,Bounce\"></range>\n    <range name=\"scramble\" title=\"Scramble Length\" list=\"20,25,30\"></range>\n    <range name=\"fov\" title=\"Camera Angle\" list=\"Ortographic,Perspective\"></range>\n    <range name=\"theme\" title=\"Color Scheme\" list=\"Cube,Erno,Dust,Camo,Rain\"></range>\n  </div>\n\n  <div class=\"ui__theme\">\n    <range name=\"hue\" title=\"Hue\" color></range>\n    <range name=\"saturation\" title=\"Saturation\" color></range>\n    <range name=\"lightness\" title=\"Lightness\" color></range>\n  </div>\n\n  <div class=\"ui__stats\">\n    <div class=\"stats\" name=\"cube-size\">\n      <i>Cube:</i><b>3x3x3</b>\n    </div>\n    <div class=\"stats\" name=\"total-solves\">\n      <i>Total solves:</i><b>-</b>\n    </div>\n    <div class=\"stats\" name=\"best-time\">\n      <i>Best time:</i><b>-</b>\n    </div>\n    <div class=\"stats\" name=\"worst-time\">\n      <i>Worst time:</i><b>-</b>\n    </div>\n    <div class=\"stats\" name=\"average-5\">\n      <i>Average of 5:</i><b>-</b>\n    </div>\n    <div class=\"stats\" name=\"average-12\">\n      <i>Average of 12:</i><b>-</b>\n    </div>\n    <div class=\"stats\" name=\"average-25\">\n      <i>Average of 25:</i><b>-</b>\n    </div>\n  </div>\n\n  <div class=\"ui__buttons\">\n    <button class=\"btn btn--bl btn--stats\">\n      <icon trophy></icon>\n    </button>\n    <button class=\"btn btn--br btn--prefs\">\n      <icon settings></icon>\n    </button>\n    <button class=\"btn btn--bl btn--back\">\n      <icon back></icon>\n    </button>\n    <button class=\"btn btn--br btn--theme\">\n      <icon theme></icon>\n    </button>\n    <button class=\"btn btn--br btn--reset\">\n      <icon reset></icon>\n    </button>\n  </div>\n\n</div>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/95/three.min.js\"></script>\n<script>\n// Console forwarding\nconst originalLog = console.log;\nconst originalError = console.error;\nconsole.log = function(...args) {\n  window.ReactNativeWebView?.postMessage(JSON.stringify({ type: 'log', message: args.join(' ') }));\n  originalLog.apply(console, args);\n};\nconsole.error = function(...args) {\n  window.ReactNativeWebView?.postMessage(JSON.stringify({ type: 'error', message: args.join(' ') }));\n  originalError.apply(console, args);\n};\n\n// Three.js - https://github.com/mrdoob/three.js/\n// RoundedBoxGeometry - https://github.com/pailhead/three-rounded-box\n\nconst animationEngine = ( () => {\n\n  let uniqueID = 0;\n\n  class AnimationEngine {\n\n    constructor() {\n\n      this.ids = [];\n      this.animations = {};\n      this.update = this.update.bind( this );\n      this.raf = 0;\n      this.time = 0;\n\n    }\n\n    update() {\n\n      const now = performance.now();\n      const delta = now - this.time;\n      this.time = now;\n\n      let i = this.ids.length;\n\n      this.raf = i ? requestAnimationFrame( this.update ) : 0;\n\n      while ( i-- )\n        this.animations[ this.ids[ i ] ] && this.animations[ this.ids[ i ] ].update( delta );\n\n    }\n\n    add( animation ) {\n\n      animation.id = uniqueID ++;\n\n      this.ids.push( animation.id );\n      this.animations[ animation.id ] = animation;\n\n      if ( this.raf !== 0 ) return;\n\n      this.time = performance.now();\n      this.raf = requestAnimationFrame( this.update );\n\n    }\n\n    remove( animation ) {\n\n      const index = this.ids.indexOf( animation.id );\n\n      if ( index < 0 ) return;\n\n      this.ids.splice( index, 1 );\n      delete this.animations[ animation.id ];\n      animation = null;\n\n    }\n\n  }\n\n  return new AnimationEngine();\n\n} )();\n\nclass Animation {\n\n  constructor( start ) {\n\n    if ( start === true ) this.start();\n\n  }\n\n  start() {\n\n    animationEngine.add( this );\n\n  }\n\n  stop() {\n\n    animationEngine.remove( this );\n\n  }\n\n  update( delta ) {}\n\n}\n\nclass World extends Animation {\n\n  constructor( game ) {\n\n    super( true );\n\n    this.game = game;\n\n    this.container = this.game.dom.game;\n    this.scene = new THREE.Scene();\n\n    this.renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n    this.renderer.setPixelRatio( window.devicePixelRatio );\n    this.container.appendChild( this.renderer.domElement );\n\n    this.camera = new THREE.PerspectiveCamera( 2, 1, 0.1, 10000 );\n\n    this.stage = { width: 2, height: 3 };\n    this.fov = 10;\n\n    this.createLights();\n\n    this.onResize = [];\n\n    this.resize();\n    window.addEventListener( 'resize', () => this.resize(), false );\n\n  }\n\n  update() {\n\n    this.renderer.render( this.scene, this.camera );\n\n  }\n\n  resize() {\n\n    this.width = this.container.offsetWidth;\n    this.height = this.container.offsetHeight;\n\n    this.renderer.setSize( this.width, this.height );\n\n    this.camera.fov = this.fov;\n    this.camera.aspect = this.width / this.height;\n\n    const aspect = this.stage.width / this.stage.height;\n    const fovRad = this.fov * THREE.Math.DEG2RAD;\n\n    let distance = ( aspect < this.camera.aspect )\n      ? ( this.stage.height / 2 ) / Math.tan( fovRad / 2 )\n      : ( this.stage.width / this.camera.aspect ) / ( 2 * Math.tan( fovRad / 2 ) );\n\n    distance *= 0.5;\n\n    this.camera.position.set( distance, distance, distance);\n    this.camera.lookAt( this.scene.position );\n    this.camera.updateProjectionMatrix();\n\n    const docFontSize = ( aspect < this.camera.aspect )\n      ? ( this.height / 100 ) * aspect\n      : this.width / 100;\n\n    document.documentElement.style.fontSize = docFontSize + 'px';\n\n    if ( this.onResize ) this.onResize.forEach( cb => cb() );\n\n  }\n\n  createLights() {\n\n    this.lights = {\n      holder:  new THREE.Object3D,\n      ambient: new THREE.AmbientLight( 0xffffff, 0.69 ),\n      front:   new THREE.DirectionalLight( 0xffffff, 0.36 ),\n      back:    new THREE.DirectionalLight( 0xffffff, 0.19 ),\n    };\n\n    this.lights.front.position.set( 1.5, 5, 3 );\n    this.lights.back.position.set( -1.5, -5, -3 );\n\n    this.lights.holder.add( this.lights.ambient );\n    this.lights.holder.add( this.lights.front );\n    this.lights.holder.add( this.lights.back );\n\n    this.scene.add( this.lights.holder );\n\n  }\n\n}\n\nfunction RoundedBoxGeometry( size, radius, radiusSegments ) {\n\n  THREE.BufferGeometry.call( this );\n\n  this.type = 'RoundedBoxGeometry';\n\n  radiusSegments = ! isNaN( radiusSegments ) ? Math.max( 1, Math.floor( radiusSegments ) ) : 1;\n\n  var width, height, depth;\n\n  width = height = depth = size;\n  radius = size * radius;\n\n  radius = Math.min( radius, Math.min( width, Math.min( height, Math.min( depth ) ) ) / 2 );\n\n  var edgeHalfWidth = width / 2 - radius;\n  var edgeHalfHeight = height / 2 - radius;\n  var edgeHalfDepth = depth / 2 - radius;\n\n  this.parameters = {\n    width: width,\n    height: height,\n    depth: depth,\n    radius: radius,\n    radiusSegments: radiusSegments\n  };\n\n  var rs1 = radiusSegments + 1;\n  var totalVertexCount = ( rs1 * radiusSegments + 1 ) << 3;\n\n  var positions = new THREE.BufferAttribute( new Float32Array( totalVertexCount * 3 ), 3 );\n  var normals = new THREE.BufferAttribute( new Float32Array( totalVertexCount * 3 ), 3 );\n\n  var\n    cornerVerts = [],\n    cornerNormals = [],\n    normal = new THREE.Vector3(),\n    vertex = new THREE.Vector3(),\n    vertexPool = [],\n    normalPool = [],\n    indices = []\n  ;\n\n  var\n    lastVertex = rs1 * radiusSegments,\n    cornerVertNumber = rs1 * radiusSegments + 1\n  ;\n\n  doVertices();\n  doFaces();\n  doCorners();\n  doHeightEdges();\n  doWidthEdges();\n  doDepthEdges();\n\n  function doVertices() {\n\n    var cornerLayout = [\n      new THREE.Vector3( 1, 1, 1 ),\n      new THREE.Vector3( 1, 1, - 1 ),\n      new THREE.Vector3( - 1, 1, - 1 ),\n      new THREE.Vector3( - 1, 1, 1 ),\n      new THREE.Vector3( 1, - 1, 1 ),\n      new THREE.Vector3( 1, - 1, - 1 ),\n      new THREE.Vector3( - 1, - 1, - 1 ),\n      new THREE.Vector3( - 1, - 1, 1 )\n    ];\n\n    for ( var j = 0; j < 8; j ++ ) {\n\n      cornerVerts.push( [] );\n      cornerNormals.push( [] );\n\n    }\n\n    var PIhalf = Math.PI / 2;\n    var cornerOffset = new THREE.Vector3( edgeHalfWidth, edgeHalfHeight, edgeHalfDepth );\n\n    for ( var y = 0; y <= radiusSegments; y ++ ) {\n\n      var v = y / radiusSegments;\n      var va = v * PIhalf;\n      var cosVa = Math.cos( va );\n      var sinVa = Math.sin( va );\n\n      if ( y == radiusSegments ) {\n\n        vertex.set( 0, 1, 0 );\n        var vert = vertex.clone().multiplyScalar( radius ).add( cornerOffset );\n        cornerVerts[ 0 ].push( vert );\n        vertexPool.push( vert );\n        var norm = vertex.clone();\n        cornerNormals[ 0 ].push( norm );\n        normalPool.push( norm );\n        continue;\n\n      }\n\n      for ( var x = 0; x <= radiusSegments; x ++ ) {\n\n        var u = x / radiusSegments;\n        var ha = u * PIhalf;\n        vertex.x = cosVa * Math.cos( ha );\n        vertex.y = sinVa;\n        vertex.z = cosVa * Math.sin( ha );\n\n        var vert = vertex.clone().multiplyScalar( radius ).add( cornerOffset );\n        cornerVerts[ 0 ].push( vert );\n        vertexPool.push( vert );\n\n        var norm = vertex.clone().normalize();\n        cornerNormals[ 0 ].push( norm );\n        normalPool.push( norm );\n\n      }\n\n    }\n\n    for ( var i = 1; i < 8; i ++ ) {\n\n      for ( var j = 0; j < cornerVerts[ 0 ].length; j ++ ) {\n\n        var vert = cornerVerts[ 0 ][ j ].clone().multiply( cornerLayout[ i ] );\n        cornerVerts[ i ].push( vert );\n        vertexPool.push( vert );\n\n        var norm = cornerNormals[ 0 ][ j ].clone().multiply( cornerLayout[ i ] );\n        cornerNormals[ i ].push( norm );\n        normalPool.push( norm );\n\n      }\n\n    }\n\n  }\n\n  function doCorners() {\n\n    var flips = [\n      true,\n      false,\n      true,\n      false,\n      false,\n      true,\n      false,\n      true\n    ];\n\n    var lastRowOffset = rs1 * ( radiusSegments - 1 );\n\n    for ( var i = 0; i < 8; i ++ ) {\n\n      var cornerOffset = cornerVertNumber * i;\n\n      for ( var v = 0; v < radiusSegments - 1; v ++ ) {\n\n        var r1 = v * rs1;\n        var r2 = ( v + 1 ) * rs1;\n\n        for ( var u = 0; u < radiusSegments; u ++ ) {\n\n          var u1 = u + 1;\n          var a = cornerOffset + r1 + u;\n          var b = cornerOffset + r1 + u1;\n          var c = cornerOffset + r2 + u;\n          var d = cornerOffset + r2 + u1;\n\n          if ( ! flips[ i ] ) {\n\n            indices.push( a );\n            indices.push( b );\n            indices.push( c );\n\n            indices.push( b );\n            indices.push( d );\n            indices.push( c );\n\n          } else {\n\n            indices.push( a );\n            indices.push( c );\n            indices.push( b );\n\n            indices.push( b );\n            indices.push( c );\n            indices.push( d );\n\n          }\n\n        }\n\n      }\n\n      for ( var u = 0; u < radiusSegments; u ++ ) {\n\n        var a = cornerOffset + lastRowOffset + u;\n        var b = cornerOffset + lastRowOffset + u + 1;\n        var c = cornerOffset + lastVertex;\n\n        if ( ! flips[ i ] ) {\n\n          indices.push( a );\n          indices.push( b );\n          indices.push( c );\n\n        } else {\n\n          indices.push( a );\n          indices.push( c );\n          indices.push( b );\n\n        }\n\n      }\n\n    }\n\n  }\n\n  function doFaces() {\n\n    var a = lastVertex;\n    var b = lastVertex + cornerVertNumber;\n    var c = lastVertex + cornerVertNumber * 2;\n    var d = lastVertex + cornerVertNumber * 3;\n\n    indices.push( a );\n    indices.push( b );\n    indices.push( c );\n    indices.push( a );\n    indices.push( c );\n    indices.push( d );\n\n    a = lastVertex + cornerVertNumber * 4;\n    b = lastVertex + cornerVertNumber * 5;\n    c = lastVertex + cornerVertNumber * 6;\n    d = lastVertex + cornerVertNumber * 7;\n\n    indices.push( a );\n    indices.push( c );\n    indices.push( b );\n    indices.push( a );\n    indices.push( d );\n    indices.push( c );\n\n    a = 0;\n    b = cornerVertNumber;\n    c = cornerVertNumber * 4;\n    d = cornerVertNumber * 5;\n\n    indices.push( a );\n    indices.push( c );\n    indices.push( b );\n    indices.push( b );\n    indices.push( c );\n    indices.push( d );\n\n    a = cornerVertNumber * 2;\n    b = cornerVertNumber * 3;\n    c = cornerVertNumber * 6;\n    d = cornerVertNumber * 7;\n\n    indices.push( a );\n    indices.push( c );\n    indices.push( b );\n    indices.push( b );\n    indices.push( c );\n    indices.push( d );\n\n    a = radiusSegments;\n    b = radiusSegments + cornerVertNumber * 3;\n    c = radiusSegments + cornerVertNumber * 4;\n    d = radiusSegments + cornerVertNumber * 7;\n\n    indices.push( a );\n    indices.push( b );\n    indices.push( c );\n    indices.push( b );\n    indices.push( d );\n    indices.push( c );\n\n    a = radiusSegments + cornerVertNumber;\n    b = radiusSegments + cornerVertNumber * 2;\n    c = radiusSegments + cornerVertNumber * 5;\n    d = radiusSegments + cornerVertNumber * 6;\n\n    indices.push( a );\n    indices.push( c );\n    indices.push( b );\n    indices.push( b );\n    indices.push( c );\n    indices.push( d );\n\n  }\n\n  function doHeightEdges() {\n\n    for ( var i = 0; i < 4; i ++ ) {\n\n      var cOffset = i * cornerVertNumber;\n      var cRowOffset = 4 * cornerVertNumber + cOffset;\n      var needsFlip = i & 1 === 1;\n\n      for ( var u = 0; u < radiusSegments; u ++ ) {\n\n        var u1 = u + 1;\n        var a = cOffset + u;\n        var b = cOffset + u1;\n        var c = cRowOffset + u;\n        var d = cRowOffset + u1;\n\n        if ( ! needsFlip ) {\n\n          indices.push( a );\n          indices.push( b );\n          indices.push( c );\n          indices.push( b );\n          indices.push( d );\n          indices.push( c );\n\n        } else {\n\n          indices.push( a );\n          indices.push( c );\n          indices.push( b );\n          indices.push( b );\n          indices.push( c );\n          indices.push( d );\n\n        }\n\n      }\n\n    }\n\n  }\n\n  function doDepthEdges() {\n\n    var cStarts = [ 0, 2, 4, 6 ];\n    var cEnds = [ 1, 3, 5, 7 ];\n\n    for ( var i = 0; i < 4; i ++ ) {\n\n      var cStart = cornerVertNumber * cStarts[ i ];\n      var cEnd = cornerVertNumber * cEnds[ i ];\n\n      var needsFlip = 1 >= i;\n\n      for ( var u = 0; u < radiusSegments; u ++ ) {\n\n        var urs1 = u * rs1;\n        var u1rs1 = ( u + 1 ) * rs1;\n\n        var a = cStart + urs1;\n        var b = cStart + u1rs1;\n        var c = cEnd + urs1;\n        var d = cEnd + u1rs1;\n\n        if ( needsFlip ) {\n\n          indices.push( a );\n          indices.push( c );\n          indices.push( b );\n          indices.push( b );\n          indices.push( c );\n          indices.push( d );\n\n        } else {\n\n          indices.push( a );\n          indices.push( b );\n          indices.push( c );\n          indices.push( b );\n          indices.push( d );\n          indices.push( c );\n\n        }\n\n      }\n\n    }\n\n  }\n\n  function doWidthEdges() {\n\n    var end = radiusSegments - 1;\n\n    var cStarts = [ 0, 1, 4, 5 ];\n    var cEnds = [ 3, 2, 7, 6 ];\n    var needsFlip = [ 0, 1, 1, 0 ];\n\n    for ( var i = 0; i < 4; i ++ ) {\n\n      var cStart = cStarts[ i ] * cornerVertNumber;\n      var cEnd = cEnds[ i ] * cornerVertNumber;\n\n      for ( var u = 0; u <= end; u ++ ) {\n\n        var a = cStart + radiusSegments + u * rs1;\n        var b = cStart + ( u != end ? radiusSegments + ( u + 1 ) * rs1 : cornerVertNumber - 1 );\n\n        var c = cEnd + radiusSegments + u * rs1;\n        var d = cEnd + ( u != end ? radiusSegments + ( u + 1 ) * rs1 : cornerVertNumber - 1 );\n\n        if ( ! needsFlip[ i ] ) {\n\n          indices.push( a );\n          indices.push( b );\n          indices.push( c );\n          indices.push( b );\n          indices.push( d );\n          indices.push( c );\n\n        } else {\n\n          indices.push( a );\n          indices.push( c );\n          indices.push( b );\n          indices.push( b );\n          indices.push( c );\n          indices.push( d );\n\n        }\n\n      }\n\n    }\n\n  }\n\n  var index = 0;\n\n  for ( var i = 0; i < vertexPool.length; i ++ ) {\n\n    positions.setXYZ(\n      index,\n      vertexPool[ i ].x,\n      vertexPool[ i ].y,\n      vertexPool[ i ].z\n    );\n\n    normals.setXYZ(\n      index,\n      normalPool[ i ].x,\n      normalPool[ i ].y,\n      normalPool[ i ].z\n    );\n\n    index ++;\n\n  }\n\n  this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\n  this.addAttribute( 'position', positions );\n  this.addAttribute( 'normal', normals );\n\n}\n\nRoundedBoxGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\nRoundedBoxGeometry.constructor = RoundedBoxGeometry;\n\nfunction RoundedPlaneGeometry( size, radius, depth ) {\n\n  var x, y, width, height;\n\n  x = y = - size / 2;\n  width = height = size;\n  radius = size * radius;\n\n  const shape = new THREE.Shape();\n\n  shape.moveTo( x, y + radius );\n  shape.lineTo( x, y + height - radius );\n  shape.quadraticCurveTo( x, y + height, x + radius, y + height );\n  shape.lineTo( x + width - radius, y + height );\n  shape.quadraticCurveTo( x + width, y + height, x + width, y + height - radius );\n  shape.lineTo( x + width, y + radius );\n  shape.quadraticCurveTo( x + width, y, x + width - radius, y );\n  shape.lineTo( x + radius, y );\n  shape.quadraticCurveTo( x, y, x, y + radius );\n\n  const geometry = new THREE.ExtrudeBufferGeometry(\n    shape,\n    { depth: depth, bevelEnabled: false, curveSegments: 3 }\n  );\n\n  return geometry;\n\n}\n\nclass Cube {\n\n  constructor( game ) {\n\n    this.game = game;\n    this.size = 3;\n\n    this.geometry = {\n      pieceCornerRadius: 0.12,\n      edgeCornerRoundness: 0.15,\n      edgeScale: 0.82,\n      edgeDepth: 0.01,\n    };\n\n    this.holder = new THREE.Object3D();\n    this.object = new THREE.Object3D();\n    this.animator = new THREE.Object3D();\n\n    this.holder.add( this.animator );\n    this.animator.add( this.object );\n\n    this.game.world.scene.add( this.holder );\n\n  }\n\n  init() {\n\n    this.cubes = [];\n    this.object.children = [];\n    this.object.add( this.game.controls.group );\n\n    if ( this.size === 2 ) this.scale = 1.25;\n    else if ( this.size === 3 ) this.scale = 1;\n    else if ( this.size > 3 ) this.scale = 3 / this.size;\n\n    this.object.scale.set( this.scale, this.scale, this.scale );\n\n    const controlsScale = this.size === 2 ? 0.825 : 1;\n    this.game.controls.edges.scale.set( controlsScale, controlsScale, controlsScale );\n    \n    this.generatePositions();\n    this.generateModel();\n\n    this.pieces.forEach( piece => {\n\n      this.cubes.push( piece.userData.cube );\n      this.object.add( piece );\n\n    } );\n\n    this.holder.traverse( node => {\n\n      if ( node.frustumCulled ) node.frustumCulled = false;\n\n    } );\n\n    this.updateColors( this.game.themes.getColors() );\n\n    this.sizeGenerated = this.size;\n\n  }\n\n  resize( force = false ) {\n\n    if ( this.size !== this.sizeGenerated || force ) {\n\n      this.size = this.game.preferences.ranges.size.value;\n\n      this.reset();\n      this.init();\n\n      this.game.saved = false;\n      this.game.timer.reset();\n      this.game.storage.clearGame();\n\n    }\n\n  }\n\n  reset() {\n\n    this.game.controls.edges.rotation.set( 0, 0, 0 );\n\n    this.holder.rotation.set( 0, 0, 0 );\n    this.object.rotation.set( 0, 0, 0 );\n    this.animator.rotation.set( 0, 0, 0 );\n\n  }\n\n  generatePositions() {\n\n    const m = this.size - 1;\n    const first = this.size % 2 !== 0\n      ? 0 - Math.floor(this.size / 2)\n      : 0.5 - this.size / 2;\n\n    let x, y, z;\n\n    this.positions = [];\n\n    for ( x = 0; x < this.size; x ++ ) {\n      for ( y = 0; y < this.size; y ++ ) {\n        for ( z = 0; z < this.size; z ++ ) {\n\n          let position = new THREE.Vector3(first + x, first + y, first + z);\n          let edges = [];\n\n          if ( x == 0 ) edges.push(0);\n          if ( x == m ) edges.push(1);\n          if ( y == 0 ) edges.push(2);\n          if ( y == m ) edges.push(3);\n          if ( z == 0 ) edges.push(4);\n          if ( z == m ) edges.push(5);\n\n          position.edges = edges;\n          this.positions.push( position );\n\n        }\n      }\n    }\n\n  }\n\n  generateModel() {\n\n    this.pieces = [];\n    this.edges = [];\n\n    const pieceSize = 1 / 3;\n\n    const mainMaterial = new THREE.MeshLambertMaterial();\n\n    const pieceMesh = new THREE.Mesh(\n      new RoundedBoxGeometry( pieceSize, this.geometry.pieceCornerRadius, 3 ),\n      mainMaterial.clone()\n    );\n\n    const edgeGeometry = RoundedPlaneGeometry(\n      pieceSize,\n      this.geometry.edgeCornerRoundness,\n      this.geometry.edgeDepth\n    );\n\n    this.positions.forEach( ( position, index ) => {\n\n      const piece = new THREE.Object3D();\n      const pieceCube = pieceMesh.clone();\n      const pieceEdges = [];\n\n      piece.position.copy( position.clone().divideScalar( 3 ) );\n      piece.add( pieceCube );\n      piece.name = index;\n      piece.edgesName = '';\n\n      position.edges.forEach( position => {\n\n        const edge = new THREE.Mesh( edgeGeometry, mainMaterial.clone() );\n        const name = [ 'L', 'R', 'D', 'U', 'B', 'F' ][ position ];\n        const distance = pieceSize / 2;\n\n        edge.position.set(\n          distance * [ - 1, 1, 0, 0, 0, 0 ][ position ],\n          distance * [ 0, 0, - 1, 1, 0, 0 ][ position ],\n          distance * [ 0, 0, 0, 0, - 1, 1 ][ position ]\n        );\n\n        edge.rotation.set(\n          Math.PI / 2 * [ 0, 0, 1, - 1, 0, 0 ][ position ],\n          Math.PI / 2 * [ - 1, 1, 0, 0, 2, 0 ][ position ],\n          0\n        );\n\n        edge.scale.set(\n          this.geometry.edgeScale,\n          this.geometry.edgeScale,\n          this.geometry.edgeScale\n        );\n\n        edge.name = name;\n\n        piece.add( edge );\n        pieceEdges.push( name );\n        this.edges.push( edge );\n\n      } );\n\n      piece.userData.edges = pieceEdges;\n      piece.userData.cube = pieceCube;\n\n      piece.userData.start = {\n        position: piece.position.clone(),\n        rotation: piece.rotation.clone(),\n      };\n\n      this.pieces.push( piece );\n\n    } );\n\n  }\n\n  updateColors( colors ) {\n\n    if ( typeof this.pieces !== 'object' && typeof this.edges !== 'object' ) return;\n\n    this.pieces.forEach( piece => piece.userData.cube.material.color.setHex( colors.P ) );\n    this.edges.forEach( edge => edge.material.color.setHex( colors[ edge.name ] ) );\n\n  }\n\n  loadFromData( data ) {\n\n    this.size = data.size;\n\n    this.reset();\n    this.init();\n\n    this.pieces.forEach( piece => {\n\n      const index = data.names.indexOf( piece.name );\n\n      const position = data.positions[index];\n      const rotation = data.rotations[index];\n\n      piece.position.set( position.x, position.y, position.z );\n      piece.rotation.set( rotation.x, rotation.y, rotation.z );\n\n    } );\n\n  }\n\n}\n\nconst Easing = {\n\n  Power: {\n\n    In: power => {\n\n      power = Math.round( power || 1 );\n\n      return t => Math.pow( t, power );\n\n    },\n\n    Out: power => {\n\n      power = Math.round( power || 1 );\n\n      return t => 1 - Math.abs( Math.pow( t - 1, power ) );\n\n    },\n\n    InOut: power => {\n\n      power = Math.round( power || 1 );\n\n      return t => ( t < 0.5 )\n        ? Math.pow( t * 2, power ) / 2\n        : ( 1 - Math.abs( Math.pow( ( t * 2 - 1 ) - 1, power ) ) ) / 2 + 0.5;\n\n    },\n\n  },\n\n  Sine: {\n\n    In: () => t => 1 + Math.sin( Math.PI / 2 * t - Math.PI / 2 ),\n\n    Out: () => t => Math.sin( Math.PI / 2 * t ),\n\n    InOut: () => t => ( 1 + Math.sin( Math.PI * t - Math.PI / 2 ) ) / 2,\n\n  },\n\n  Back: {\n\n    Out: s => {\n\n      s = s || 1.70158;\n\n      return t => { return ( t -= 1 ) * t * ( ( s + 1 ) * t + s ) + 1; };\n\n    },\n\n    In: s => {\n\n      s = s || 1.70158;\n\n      return t => { return t * t * ( ( s + 1 ) * t - s ); };\n\n    }\n\n  },\n\n  Elastic: {\n\n    Out: ( amplitude, period ) => {\n\n      let PI2 = Math.PI * 2;\n\n      let p1 = ( amplitude >= 1 ) ? amplitude : 1;\n      let p2 = ( period || 0.3 ) / ( amplitude < 1 ? amplitude : 1 );\n      let p3 = p2 / PI2 * ( Math.asin( 1 / p1 ) || 0 );\n\n      p2 = PI2 / p2;\n\n      return t => { return p1 * Math.pow( 2, -10 * t ) * Math.sin( ( t - p3 ) * p2 ) + 1 }\n\n    },\n\n  },\n\n};\n\nclass Tween extends Animation {\n\n  constructor( options ) {\n\n    super( false );\n\n    this.duration = options.duration || 500;\n    this.easing = options.easing || ( t => t );\n    this.onUpdate = options.onUpdate || ( () => {} );\n    this.onComplete = options.onComplete || ( () => {} );\n\n    this.delay = options.delay || false;\n    this.yoyo = options.yoyo ? false : null;\n\n    this.progress = 0;\n    this.value = 0;\n    this.delta = 0;\n\n    this.getFromTo( options );\n\n    if ( this.delay ) setTimeout( () => super.start(), this.delay );\n    else super.start();\n\n    this.onUpdate( this );\n\n  }\n\n  update( delta ) {\n\n    const old = this.value * 1;\n    const direction = ( this.yoyo === true ) ? - 1 : 1;\n\n    this.progress += ( delta / this.duration ) * direction;\n\n    this.value = this.easing( this.progress );\n    this.delta = this.value - old;\n\n    if ( this.values !== null ) this.updateFromTo();\n\n    if ( this.yoyo !== null ) this.updateYoyo();\n    else if ( this.progress <= 1 ) this.onUpdate( this );\n    else {\n\n      this.progress = 1;\n      this.value = 1;\n      this.onUpdate( this );\n      this.onComplete( this );\n      super.stop();      \n\n    }\n\n  }\n\n  updateYoyo() {\n\n    if ( this.progress > 1 || this.progress < 0 ) {\n\n      this.value = this.progress = ( this.progress > 1 ) ? 1 : 0;\n      this.yoyo = ! this.yoyo;\n\n    }\n\n    this.onUpdate( this );\n\n  }\n\n  updateFromTo() {\n\n    this.values.forEach( key => {\n\n      this.target[ key ] = this.from[ key ] + ( this.to[ key ] - this.from[ key ] ) * this.value;\n\n    } );\n\n  }\n\n  getFromTo( options ) {\n\n    if ( ! options.target || ! options.to ) {\n\n      this.values = null;\n      return;\n\n    }\n\n    this.target = options.target || null;\n    this.from = options.from || {};\n    this.to = options.to || null;\n    this.values = [];\n\n    if ( Object.keys( this.from ).length < 1 )\n      Object.keys( this.to ).forEach( key => { this.from[ key ] = this.target[ key ]; } );\n\n    Object.keys( this.to ).forEach( key => { this.values.push( key ); } );\n\n  }\n\n}\n\nwindow.addEventListener( 'touchmove', () => {} );\ndocument.addEventListener( 'touchmove',  event => { event.preventDefault(); }, { passive: false } );\n\nclass Draggable {\n\n  constructor( element, options ) {\n\n    this.position = {\n      current: new THREE.Vector2(),\n      start: new THREE.Vector2(),\n      delta: new THREE.Vector2(),\n      old: new THREE.Vector2(),\n      drag: new THREE.Vector2(),\n    };\n\n    this.options = Object.assign( {\n      calcDelta: false,\n    }, options || {} );\n\n    this.element = element;\n    this.touch = null;\n\n    this.drag = {\n\n      start: ( event ) => {\n\n        if ( event.type == 'mousedown' && event.which != 1 ) return;\n        if ( event.type == 'touchstart' && event.touches.length > 1 ) return;\n\n        this.getPositionCurrent( event );\n\n        if ( this.options.calcDelta ) {\n\n          this.position.start = this.position.current.clone();\n          this.position.delta.set( 0, 0 );\n          this.position.drag.set( 0, 0 );\n\n        }\n\n        this.touch = ( event.type == 'touchstart' );\n\n        this.onDragStart( this.position );\n\n        window.addEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );\n        window.addEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );\n\n      },\n\n      move: ( event ) => {\n\n        if ( this.options.calcDelta ) {\n\n          this.position.old = this.position.current.clone();\n\n        }\n\n        this.getPositionCurrent( event );\n\n        if ( this.options.calcDelta ) {\n\n          this.position.delta = this.position.current.clone().sub( this.position.old );\n          this.position.drag = this.position.current.clone().sub( this.position.start );\n\n        }\n\n        this.onDragMove( this.position );\n\n      },\n\n      end: ( event ) => {\n\n        this.getPositionCurrent( event );\n\n        this.onDragEnd( this.position );\n\n        window.removeEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );\n        window.removeEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );\n\n      },\n\n    };\n\n    this.onDragStart = () => {};\n    this.onDragMove = () => {};\n    this.onDragEnd = () => {};\n\n    this.enable();\n\n    return this;\n\n  }\n\n  enable() {\n\n    this.element.addEventListener( 'touchstart', this.drag.start, false );\n    this.element.addEventListener( 'mousedown', this.drag.start, false );\n\n    return this;\n\n  }\n\n  disable() {\n\n    this.element.removeEventListener( 'touchstart', this.drag.start, false );\n    this.element.removeEventListener( 'mousedown', this.drag.start, false );\n\n    return this;\n\n  }\n\n  getPositionCurrent( event ) {\n\n    const dragEvent = event.touches\n      ? ( event.touches[ 0 ] || event.changedTouches[ 0 ] )\n      : event;\n\n    this.position.current.set( dragEvent.pageX, dragEvent.pageY );\n\n  }\n\n  convertPosition( position ) {\n\n    position.x = ( position.x / this.element.offsetWidth ) * 2 - 1;\n    position.y = - ( ( position.y / this.element.offsetHeight ) * 2 - 1 );\n\n    return position;\n\n  }\n\n}\n\nconst STILL = 0;\nconst PREPARING = 1;\nconst ROTATING = 2;\nconst ANIMATING = 3;\n\nclass Controls {\n\n  constructor( game ) {\n\n    this.game = game;\n\n    this.flipConfig = 0;\n\n    this.flipEasings = [ Easing.Power.Out( 3 ), Easing.Sine.Out(), Easing.Back.Out( 1.5 ) ];\n    this.flipSpeeds = [ 125, 200, 300 ];\n\n    this.raycaster = new THREE.Raycaster();\n\n    const helperMaterial = new THREE.MeshBasicMaterial( { depthWrite: false, transparent: true, opacity: 0, color: 0x0033ff } );\n\n    this.group = new THREE.Object3D();\n    this.group.name = 'controls';\n    this.game.cube.object.add( this.group );\n\n    this.helper = new THREE.Mesh(\n      new THREE.PlaneBufferGeometry( 200, 200 ),\n      helperMaterial.clone()\n    );\n\n    this.helper.rotation.set( 0, Math.PI / 4, 0 );\n    this.game.world.scene.add( this.helper );\n\n    this.edges = new THREE.Mesh(\n      new THREE.BoxBufferGeometry( 1, 1, 1 ),\n      helperMaterial.clone(),\n    );\n\n    this.game.world.scene.add( this.edges );\n\n    this.onSolved = () => {};\n    this.onMove = () => {};\n\n    this.momentum = [];\n\n    this.scramble = null;\n    this.state = STILL;\n    this.enabled = false;\n\n    this.initDraggable();\n\n  }\n\n  enable() {\n\n    this.draggable.enable();\n    this.enabled = true;\n\n  }\n\n  disable() {\n\n    this.draggable.disable();\n    this.enabled = false;\n\n  }\n\n  initDraggable() {\n\n    this.draggable = new Draggable( this.game.dom.game );\n\n    this.draggable.onDragStart = position => {\n\n      if ( this.scramble !== null ) return;\n      if ( this.state === PREPARING || this.state === ROTATING ) return;\n\n      this.gettingDrag = this.state === ANIMATING;\n\n      const edgeIntersect = this.getIntersect( position.current, this.edges, false );\n\n      if ( edgeIntersect !== false ) {\n\n        this.dragIntersect = this.getIntersect( position.current, this.game.cube.cubes, true );\n\n      }\n\n      if ( edgeIntersect !== false && this.dragIntersect !== false ) {\n\n        this.dragNormal = edgeIntersect.face.normal.round();\n        this.flipType = 'layer';\n\n        this.attach( this.helper, this.edges );\n\n        this.helper.rotation.set( 0, 0, 0 );\n        this.helper.position.set( 0, 0, 0 );\n        this.helper.lookAt( this.dragNormal );\n        this.helper.translateZ( 0.5 );\n        this.helper.updateMatrixWorld();\n\n        this.detach( this.helper, this.edges );\n\n      } else {\n\n        this.dragNormal = new THREE.Vector3( 0, 0, 1 );\n        this.flipType = 'cube';\n\n        this.helper.position.set( 0, 0, 0 );\n        this.helper.rotation.set( 0, Math.PI / 4, 0 );\n        this.helper.updateMatrixWorld();\n\n      }\n\n      let planeIntersect = this.getIntersect( position.current, this.helper, false );\n      if ( planeIntersect === false ) return;\n\n      this.dragCurrent = this.helper.worldToLocal( planeIntersect.point );\n      this.dragTotal = new THREE.Vector3();\n      this.state = ( this.state === STILL ) ? PREPARING : this.state;\n\n    };\n\n    this.draggable.onDragMove = position => {\n\n      if ( this.scramble !== null ) return;\n      if ( this.state === STILL || ( this.state === ANIMATING && this.gettingDrag === false ) ) return;\n\n      const planeIntersect = this.getIntersect( position.current, this.helper, false );\n      if ( planeIntersect === false ) return;\n\n      const point = this.helper.worldToLocal( planeIntersect.point.clone() );\n\n      this.dragDelta = point.clone().sub( this.dragCurrent ).setZ( 0 );\n      this.dragTotal.add( this.dragDelta );\n      this.dragCurrent = point;\n      this.addMomentumPoint( this.dragDelta );\n\n      if ( this.state === PREPARING && this.dragTotal.length() > 0.05 ) {\n\n        this.dragDirection = this.getMainAxis( this.dragTotal );\n\n        if ( this.flipType === 'layer' ) {\n\n          const direction = new THREE.Vector3();\n          direction[ this.dragDirection ] = 1;\n\n          const worldDirection = this.helper.localToWorld( direction ).sub( this.helper.position );\n          const objectDirection = this.edges.worldToLocal( worldDirection ).round();\n\n          this.flipAxis = objectDirection.cross( this.dragNormal ).negate();\n\n          this.selectLayer( this.getLayer( false ) );\n\n        } else {\n\n          const axis = ( this.dragDirection != 'x' )\n            ? ( ( this.dragDirection == 'y' && position.current.x > this.game.world.width / 2 ) ? 'z' : 'x' )\n            : 'y';\n\n          this.flipAxis = new THREE.Vector3();\n          this.flipAxis[ axis ] = 1 * ( ( axis == 'x' ) ? - 1 : 1 );\n\n        }\n\n        this.flipAngle = 0;\n        this.state = ROTATING;\n\n      } else if ( this.state === ROTATING ) {\n\n        const rotation = this.dragDelta[ this.dragDirection ];\n\n        if ( this.flipType === 'layer' ) { \n\n          this.group.rotateOnAxis( this.flipAxis, rotation );\n          this.flipAngle += rotation;\n\n        } else {\n\n          this.edges.rotateOnWorldAxis( this.flipAxis, rotation );\n          this.game.cube.object.rotation.copy( this.edges.rotation );\n          this.flipAngle += rotation;\n\n        }\n\n      }\n\n    };\n\n    this.draggable.onDragEnd = position => {\n\n      if ( this.scramble !== null ) return;\n      if ( this.state !== ROTATING ) {\n\n        this.gettingDrag = false;\n        this.state = STILL;\n        return;\n\n      }\n\n      this.state = ANIMATING;\n\n      const momentum = this.getMomentum()[ this.dragDirection ];\n      const flip = ( Math.abs( momentum ) > 0.05 && Math.abs( this.flipAngle ) < Math.PI / 2 );\n\n      const angle = flip\n        ? this.roundAngle( this.flipAngle + Math.sign( this.flipAngle ) * ( Math.PI / 4 ) )\n        : this.roundAngle( this.flipAngle );\n\n      const delta = angle - this.flipAngle;\n\n      if ( this.flipType === 'layer' ) {\n\n        this.rotateLayer( delta, false, layer => {\n\n          this.game.storage.saveGame();\n          \n          this.state = this.gettingDrag ? PREPARING : STILL;\n          this.gettingDrag = false;\n\n          this.checkIsSolved();\n\n        } );\n\n      } else {\n\n        this.rotateCube( delta, () => {\n\n          this.state = this.gettingDrag ? PREPARING : STILL;\n          this.gettingDrag = false;\n\n        } );\n\n      }\n\n    };\n\n  }\n\n  rotateLayer( rotation, scramble, callback ) {\n\n    const config = scramble ? 0 : this.flipConfig;\n\n    const easing = this.flipEasings[ config ];\n    const duration = this.flipSpeeds[ config ];\n    const bounce = ( config == 2 ) ? this.bounceCube() : ( () => {} );\n\n    this.rotationTween = new Tween( {\n      easing: easing,\n      duration: duration,\n      onUpdate: tween => {\n\n        let deltaAngle = tween.delta * rotation;\n        this.group.rotateOnAxis( this.flipAxis, deltaAngle );\n        bounce( tween.value, deltaAngle, rotation );\n\n      },\n      onComplete: () => {\n\n        if ( ! scramble ) this.onMove();\n\n        const layer = this.flipLayer.slice( 0 );\n\n        this.game.cube.object.rotation.setFromVector3( this.snapRotation( this.game.cube.object.rotation.toVector3() ) );\n        this.group.rotation.setFromVector3( this.snapRotation( this.group.rotation.toVector3() ) );\n        this.deselectLayer( this.flipLayer );\n\n        callback( layer );\n\n      },\n    } );\n\n  }\n\n  bounceCube() {\n\n    let fixDelta = true;\n\n    return ( progress, delta, rotation ) => {\n\n        if ( progress >= 1 ) {\n\n          if ( fixDelta ) {\n\n            delta = ( progress - 1 ) * rotation;\n            fixDelta = false;\n\n          }\n\n          this.game.cube.object.rotateOnAxis( this.flipAxis, delta );\n\n        }\n\n    }\n\n  }\n\n  rotateCube( rotation, callback ) {\n\n    const config = this.flipConfig;\n    const easing = [ Easing.Power.Out( 4 ), Easing.Sine.Out(), Easing.Back.Out( 2 ) ][ config ];\n    const duration = [ 100, 150, 350 ][ config ];\n\n    this.rotationTween = new Tween( {\n      easing: easing,\n      duration: duration,\n      onUpdate: tween => {\n\n        this.edges.rotateOnWorldAxis( this.flipAxis, tween.delta * rotation );\n        this.game.cube.object.rotation.copy( this.edges.rotation );\n\n      },\n      onComplete: () => {\n\n        this.edges.rotation.setFromVector3( this.snapRotation( this.edges.rotation.toVector3() ) );\n        this.game.cube.object.rotation.copy( this.edges.rotation );\n        callback();\n\n      },\n    } );\n\n  }\n\n  selectLayer( layer ) {\n\n    this.group.rotation.set( 0, 0, 0 );\n    this.movePieces( layer, this.game.cube.object, this.group );\n    this.flipLayer = layer;\n\n  }\n\n  deselectLayer( layer ) {\n\n    this.movePieces( layer, this.group, this.game.cube.object );\n    this.flipLayer = null;\n\n  }\n\n  movePieces( layer, from, to ) {\n\n    from.updateMatrixWorld();\n    to.updateMatrixWorld();\n\n    layer.forEach( index => {\n\n      const piece = this.game.cube.pieces[ index ];\n\n      piece.applyMatrix( from.matrixWorld );\n      from.remove( piece );\n      piece.applyMatrix( new THREE.Matrix4().getInverse( to.matrixWorld ) );\n      to.add( piece );\n\n    } );\n\n  }\n\n  getLayer( position ) {\n\n    const scalar = { 2: 6, 3: 3, 4: 4, 5: 3 }[ this.game.cube.size ];\n    const layer = [];\n\n    let axis;\n\n    if ( position === false ) {\n\n      const piece = this.dragIntersect.object.parent;\n\n      axis = this.getMainAxis( this.flipAxis );\n      position = piece.position.clone() .multiplyScalar( scalar ) .round();\n\n    } else {\n\n      axis = this.getMainAxis( position );\n\n    }\n\n    this.game.cube.pieces.forEach( piece => {\n\n      const piecePosition = piece.position.clone().multiplyScalar( scalar ).round();\n\n      if ( piecePosition[ axis ] == position[ axis ] ) layer.push( piece.name );\n\n    } );\n\n    return layer;\n\n  }\n\n  keyboardMove( type, move, callback ) {\n\n    if ( this.state !== STILL ) return;\n    if ( this.enabled !== true ) return;\n\n    if ( type === 'LAYER' ) {\n\n      const layer = this.getLayer( move.position );\n\n      this.flipAxis = new THREE.Vector3();\n      this.flipAxis[ move.axis ] = 1;\n      this.state = ROTATING;\n\n      this.selectLayer( layer );\n      this.rotateLayer( move.angle, false, layer => {\n\n        this.game.storage.saveGame();\n        this.state = STILL;\n        this.checkIsSolved();\n\n      } );\n\n    } else if ( type === 'CUBE' ) {\n\n      this.flipAxis = new THREE.Vector3();\n      this.flipAxis[ move.axis ] = 1;\n      this.state = ROTATING;\n\n      this.rotateCube( move.angle, () => {\n\n        this.state = STILL;\n\n      } );\n\n    }\n\n  }\n\n  scrambleCube() {\n\n    if ( this.scramble == null ) {\n\n      this.scramble = this.game.scrambler;\n      this.scramble.callback = ( typeof callback !== 'function' ) ? () => {} : callback;\n\n    }\n\n    const converted = this.scramble.converted;\n    const move = converted[ 0 ];\n    const layer = this.getLayer( move.position );\n\n    this.flipAxis = new THREE.Vector3();\n    this.flipAxis[ move.axis ] = 1;\n\n    this.selectLayer( layer );\n    this.rotateLayer( move.angle, true, () => {\n\n      converted.shift();\n\n      if ( converted.length > 0 ) {\n\n        this.scrambleCube();\n\n      } else {\n\n        this.scramble = null;\n        this.game.storage.saveGame();\n\n      }\n\n    } );\n\n  }\n\n  getIntersect( position, object, multiple ) {\n\n    this.raycaster.setFromCamera(\n      this.draggable.convertPosition( position.clone() ),\n      this.game.world.camera\n    );\n\n    const intersect = ( multiple )\n      ? this.raycaster.intersectObjects( object )\n      : this.raycaster.intersectObject( object );\n\n    return ( intersect.length > 0 ) ? intersect[ 0 ] : false;\n\n  }\n\n  getMainAxis( vector ) {\n\n    return Object.keys( vector ).reduce(\n      ( a, b ) => Math.abs( vector[ a ] ) > Math.abs( vector[ b ] ) ? a : b\n    );\n\n  }\n\n  detach( child, parent ) {\n\n    child.applyMatrix( parent.matrixWorld );\n    parent.remove( child );\n    this.game.world.scene.add( child );\n\n  }\n\n  attach( child, parent ) {\n\n    child.applyMatrix( new THREE.Matrix4().getInverse( parent.matrixWorld ) );\n    this.game.world.scene.remove( child );\n    parent.add( child );\n\n  }\n\n  addMomentumPoint( delta ) {\n\n    const time = Date.now();\n\n    this.momentum = this.momentum.filter( moment => time - moment.time < 500 );\n\n    if ( delta !== false ) this.momentum.push( { delta, time } );\n\n  }\n\n  getMomentum() {\n\n    const points = this.momentum.length;\n    const momentum = new THREE.Vector2();\n\n    this.addMomentumPoint( false );\n\n    this.momentum.forEach( ( point, index ) => {\n\n      momentum.add( point.delta.multiplyScalar( index / points ) );\n\n    } );\n\n    return momentum;\n\n  }\n\n  roundAngle( angle ) {\n\n    const round = Math.PI / 2;\n    return Math.sign( angle ) * Math.round( Math.abs( angle) / round ) * round;\n\n  }\n\n  snapRotation( angle ) {\n\n    return angle.set(\n      this.roundAngle( angle.x ),\n      this.roundAngle( angle.y ),\n      this.roundAngle( angle.z )\n    );\n\n  }\n\n  checkIsSolved() {\n\n    const start = performance.now();\n\n    let solved = true;\n    const sides = { 'x-': [], 'x+': [], 'y-': [], 'y+': [], 'z-': [], 'z+': [] };\n\n    this.game.cube.edges.forEach( edge => {\n\n      const position = edge.parent\n        .localToWorld( edge.position.clone() )\n        .sub( this.game.cube.object.position );\n\n      const mainAxis = this.getMainAxis( position );\n      const mainSign = position.multiplyScalar( 2 ).round()[ mainAxis ] < 1 ? '-' : '+';\n\n      sides[ mainAxis + mainSign ].push( edge.name );\n\n    } );\n\n    Object.keys( sides ).forEach( side => {\n\n      if ( ! sides[ side ].every( value => value === sides[ side ][ 0 ] ) ) solved = false;\n\n    } );\n\n    if ( solved ) this.onSolved();\n\n  }\n\n}\n\nclass Scrambler {\n\n  constructor( game ) {\n\n    this.game = game;\n\n    this.dificulty = 0;\n\n    this.scrambleLength = {\n      2: [ 7, 9, 11 ],\n      3: [ 20, 25, 30 ],\n      4: [ 30, 40, 50 ],\n      5: [ 40, 60, 80 ],\n    };\n\n    this.moves = [];\n    this.conveted = [];\n    this.pring = '';\n\n  }\n\n  scramble( scramble ) {\n\n    let count = 0;\n    this.moves = ( typeof scramble !== 'undefined' ) ? scramble.split( ' ' ) : [];\n\n    if ( this.moves.length < 1 ) {\n\n      const scrambleLength = this.scrambleLength[ this.game.cube.size ][ this.dificulty ];\n\n      const faces = this.game.cube.size < 4 ? 'UDLRFB' : 'UuDdLlRrFfBb';\n      const modifiers = [ \"\", \"'\", \"2\" ];\n      const total = ( typeof scramble === 'undefined' ) ? scrambleLength : scramble;\n\n      while ( count < total ) {\n\n        const move =\n          faces[ Math.floor( Math.random() * faces.length ) ] +\n          modifiers[ Math.floor( Math.random() * 3 ) ];\n\n        if ( count > 0 && move.charAt( 0 ) == this.moves[ count - 1 ].charAt( 0 ) ) continue;\n        if ( count > 1 && move.charAt( 0 ) == this.moves[ count - 2 ].charAt( 0 ) ) continue;\n\n        this.moves.push( move );\n        count ++;\n\n      }\n\n    }\n\n    this.callback = () => {};\n    this.convert();\n    this.print = this.moves.join( ' ' );\n\n    return this;\n\n  }\n\n  convert( moves ) {\n\n    this.converted = [];\n\n    this.moves.forEach( move => {\n\n      const convertedMove = this.convertMove( move );\n      const modifier = move.charAt( 1 );\n\n      this.converted.push( convertedMove );\n      if ( modifier == \"2\" ) this.converted.push( convertedMove );\n\n    } );\n\n  }\n\n  convertMove( move ) {\n\n    const face = move.charAt( 0 );\n    const modifier = move.charAt( 1 );\n\n    const axis = { D: 'y', U: 'y', L: 'x', R: 'x', F: 'z', B: 'z' }[ face.toUpperCase() ];\n    let row = { D: -1, U: 1, L: -1, R: 1, F: 1, B: -1 }[ face.toUpperCase() ];\n\n    if ( this.game.cube.size > 3 && face !== face.toLowerCase() ) row = row * 2;\n\n    const position = new THREE.Vector3();\n    position[ { D: 'y', U: 'y', L: 'x', R: 'x', F: 'z', B: 'z' }[ face.toUpperCase() ] ] = row;\n\n    const angle = ( Math.PI / 2 ) * - row * ( ( modifier == \"'\" ) ? - 1 : 1 );\n\n    return { position, axis, angle, name: move };\n\n  }\n\n}\n\nclass Transition {\n\n  constructor( game ) {\n\n    this.game = game;\n\n    this.tweens = {};\n    this.durations = {};\n    this.data = {\n      cubeY: -0.2,\n      cameraZoom: 0.85,\n    };\n\n    this.activeTransitions = 0;\n\n  }\n\n  init() {\n\n    this.game.controls.disable();\n\n    this.game.cube.object.position.y = this.data.cubeY;\n    this.game.cube.animator.position.y = 4;\n    this.game.cube.animator.rotation.x = - Math.PI / 3;\n    this.game.world.camera.zoom = this.data.cameraZoom;\n    this.game.world.camera.updateProjectionMatrix();\n\n    this.tweens.buttons = {};\n    this.tweens.timer = [];\n    this.tweens.title = [];\n    this.tweens.best = [];\n    this.tweens.complete = [];\n    this.tweens.prefs = [];\n    this.tweens.theme = [];\n    this.tweens.stats = [];\n\n  }\n\n  buttons( show, hide ) {\n\n    const buttonTween = ( button, show ) => {\n\n      return new Tween( {\n        target: button.style,\n        duration: 300,\n        easing: show ? Easing.Power.Out( 2 ) : Easing.Power.In( 3 ),\n        from: { opacity: show ? 0 : 1 },\n        to: { opacity: show ? 1 : 0 },\n        onUpdate: tween => {\n\n          const translate = show ? 1 - tween.value : tween.value;\n          button.style.transform = `translate3d(0, ${translate * 1.5}em, 0)`;\n\n        },\n        onComplete: () => button.style.pointerEvents = show ? 'all' : 'none'\n      } );\n\n    };\n\n    hide.forEach( button =>\n      this.tweens.buttons[ button ] = buttonTween( this.game.dom.buttons[ button ], false )\n    );\n\n    setTimeout( () => show.forEach( button => {\n\n      this.tweens.buttons[ button ] = buttonTween( this.game.dom.buttons[ button ], true );\n\n    } ), hide ? 500 : 0 );\n\n  }\n\n  cube( show, theming = false ) {\n\n    this.activeTransitions++;\n\n    try { this.tweens.cube.stop(); } catch(e) {}\n    const currentY = this.game.cube.animator.position.y;\n    const currentRotation = this.game.cube.animator.rotation.x;\n\n    this.tweens.cube = new Tween( {\n      duration: show ? 3000 : 1250,\n      easing: show ? Easing.Elastic.Out( 0.8, 0.6 ) : Easing.Back.In( 1 ),\n      onUpdate: tween => {\n\n        this.game.cube.animator.position.y = show\n          ? ( theming ? 0.9 + ( 1 - tween.value ) * 3.5 : ( 1 - tween.value ) * 4 )\n          : currentY + tween.value * 4;\n\n        this.game.cube.animator.rotation.x = show\n          ? ( 1 - tween.value ) * Math.PI / 3\n          : currentRotation + tween.value * - Math.PI / 3;\n\n      },\n    } );\n\n    if ( theming ) {\n\n      if ( show ) {\n\n        this.game.world.camera.zoom = 0.75;\n        this.game.world.camera.updateProjectionMatrix();\n\n      } else {\n\n        setTimeout( () => {\n\n          this.game.world.camera.zoom = this.data.cameraZoom;\n          this.game.world.camera.updateProjectionMatrix();\n\n        }, 1500 );\n\n      }\n\n    }\n\n    this.durations.cube = show ? 1500 : 1500;\n\n    setTimeout( () => this.activeTransitions--, this.durations.cube );\n\n  }\n\n  float() {\n\n    try { this.tweens.float.stop(); } catch(e) {}\n    this.tweens.float = new Tween( {\n      duration: 1500,\n      easing: Easing.Sine.InOut(),\n      yoyo: true,\n      onUpdate: tween => {\n\n        this.game.cube.holder.position.y = (- 0.02 + tween.value * 0.04); \n        this.game.cube.holder.rotation.x = 0.005 - tween.value * 0.01;\n        this.game.cube.holder.rotation.z = - this.game.cube.holder.rotation.x;\n        this.game.cube.holder.rotation.y = this.game.cube.holder.rotation.x;\n\n        this.game.controls.edges.position.y =\n          this.game.cube.holder.position.y + this.game.cube.object.position.y;\n\n      },\n    } );\n\n  }\n\n  zoom( play, time ) {\n\n    this.activeTransitions++;\n\n    const zoom = ( play ) ? 1 : this.data.cameraZoom;\n    const duration = ( time > 0 ) ? Math.max( time, 1500 ) : 1500;\n    const rotations = ( time > 0 ) ? Math.round( duration / 1500 ) : 1;\n    const easing = Easing.Power.InOut( ( time > 0 ) ? 2 : 3 );\n\n    this.tweens.zoom = new Tween( {\n      target: this.game.world.camera,\n      duration: duration,\n      easing: easing,\n      to: { zoom: zoom },\n      onUpdate: () => { this.game.world.camera.updateProjectionMatrix(); },\n    } );\n\n    this.tweens.rotate = new Tween( {\n      target: this.game.cube.animator.rotation,\n      duration: duration,\n      easing: easing,\n      to: { y: - Math.PI * 2 * rotations },\n      onComplete: () => { this.game.cube.animator.rotation.y = 0; },\n    } );\n\n    this.durations.zoom = duration;\n\n    setTimeout( () => this.activeTransitions--, this.durations.zoom );\n\n  }\n\n  elevate( complete ) {\n\n    this.activeTransitions++;\n\n    const cubeY = \n\n    this.tweens.elevate = new Tween( {\n      target: this.game.cube.object.position,\n      duration: complete ? 1500 : 0,\n      easing: Easing.Power.InOut( 3 ),\n      to: { y: complete ? -0.05 : this.data.cubeY }\n    } );\n\n    this.durations.elevate = 1500;\n\n    setTimeout( () => this.activeTransitions--, this.durations.elevate );\n\n  }\n\n  complete( show, best ) {\n\n    this.activeTransitions++;\n\n    const text = best ? this.game.dom.texts.best : this.game.dom.texts.complete;\n\n    if ( text.querySelector( 'span i' ) === null )\n      text.querySelectorAll( 'span' ).forEach( span => this.splitLetters( span ) );\n\n    const letters = text.querySelectorAll( '.icon, i' );\n\n    this.flipLetters( best ? 'best' : 'complete', letters, show );\n\n    text.style.opacity = 1;\n\n    const duration = this.durations[ best ? 'best' : 'complete' ];\n\n    if ( ! show ) setTimeout( () => this.game.dom.texts.timer.style.transform = '', duration );\n\n    setTimeout( () => this.activeTransitions--, duration );\n\n  } \n\n  stats( show ) {\n\n    if ( show ) this.game.scores.calcStats();\n\n    this.activeTransitions++;\n\n    this.tweens.stats.forEach( tween => { tween.stop(); tween = null; } );\n\n    let tweenId = -1;\n\n    const stats = this.game.dom.stats.querySelectorAll( '.stats' );\n    const easing = show ? Easing.Power.Out( 2 ) : Easing.Power.In( 3 );\n\n    stats.forEach( ( stat, index ) => {\n\n      const delay = index * ( show ? 80 : 60 );\n\n      this.tweens.stats[ tweenId++ ] = new Tween( {\n        delay: delay,\n        duration: 400,\n        easing: easing,\n        onUpdate: tween => {\n\n          const translate = show ? ( 1 - tween.value ) * 2 : tween.value;\n          const opacity = show ? tween.value : ( 1 - tween.value );\n\n          stat.style.transform = `translate3d(0, ${translate}em, 0)`;\n          stat.style.opacity = opacity;\n\n        }\n      } );\n\n    } );\n\n    this.durations.stats = 0;\n\n    setTimeout( () => this.activeTransitions--, this.durations.stats );\n\n  }\n\n  preferences( show ) {\n\n    this.ranges( this.game.dom.prefs.querySelectorAll( '.range' ), 'prefs', show );\n\n  }\n\n  theming( show ) {\n\n    this.ranges( this.game.dom.theme.querySelectorAll( '.range' ), 'prefs', show );\n\n  }\n\n  ranges( ranges, type, show ) {\n\n    this.activeTransitions++;\n\n    this.tweens[ type ].forEach( tween => { tween.stop(); tween = null; } );\n\n    const easing = show ? Easing.Power.Out(2) : Easing.Power.In(3);\n\n    let tweenId = -1;\n    let listMax = 0;\n\n    ranges.forEach( ( range, rangeIndex ) => {\n    \n      const label = range.querySelector( '.range__label' );\n      const track = range.querySelector( '.range__track-line' );\n      const handle = range.querySelector( '.range__handle' );\n      const list = range.querySelectorAll( '.range__list div' );\n\n      const delay = rangeIndex * ( show ? 120 : 100 );\n\n      label.style.opacity = show ? 0 : 1;\n      track.style.opacity = show ? 0 : 1;\n      handle.style.opacity = show ? 0 : 1;\n      handle.style.pointerEvents = show ? 'all' : 'none';\n\n      this.tweens[ type ][ tweenId++ ] = new Tween( {\n        delay: show ? delay : delay,\n        duration: 400,\n        easing: easing,\n        onUpdate: tween => {\n\n          const translate = show ? ( 1 - tween.value ) : tween.value;\n          const opacity = show ? tween.value : ( 1 - tween.value );\n\n          label.style.transform = `translate3d(0, ${translate}em, 0)`;\n          label.style.opacity = opacity;\n\n        }\n      } );\n\n      this.tweens[ type ][ tweenId++ ] = new Tween( {\n        delay: show ? delay + 100 : delay,\n        duration: 400,\n        easing: easing,\n        onUpdate: tween => {\n\n          const translate = show ? ( 1 - tween.value ) : tween.value;\n          const scale = show ? tween.value : ( 1 - tween.value );\n          const opacity = scale;\n\n          track.style.transform = `translate3d(0, ${translate}em, 0) scale3d(${scale}, 1, 1)`;\n          track.style.opacity = opacity;\n\n        }\n      } );\n\n      this.tweens[ type ][ tweenId++ ] = new Tween( {\n        delay: show ? delay + 100 : delay,\n        duration: 400,\n        easing: easing,\n        onUpdate: tween => {\n\n          const translate = show ? ( 1 - tween.value ) : tween.value;\n          const opacity = 1 - translate;\n          const scale = 0.5 + opacity * 0.5;\n\n          handle.style.transform = `translate3d(0, ${translate}em, 0) scale3d(${scale}, ${scale}, ${scale})`;\n          handle.style.opacity = opacity;\n\n        }\n      } );\n\n      list.forEach( ( listItem, labelIndex ) => {\n\n        listItem.style.opacity = show ? 0 : 1;\n\n        this.tweens[ type ][ tweenId++ ] = new Tween( {\n          delay: show ? delay + 200 + labelIndex * 50 : delay,\n          duration: 400,\n          easing: easing,\n          onUpdate: tween => {\n\n            const translate = show ? ( 1 - tween.value ) : tween.value;\n            const opacity = show ? tween.value : ( 1 - tween.value );\n\n            listItem.style.transform = `translate3d(0, ${translate}em, 0)`;\n            listItem.style.opacity = opacity;\n\n          }\n        } );\n\n      } );\n\n      listMax = list.length > listMax ? list.length - 1 : listMax;\n\n      range.style.opacity = 1;\n\n    } );\n\n    this.durations[ type ] = show\n      ? ( ( ranges.length - 1 ) * 100 ) + 200 + listMax * 50 + 400\n      : ( ( ranges.length - 1 ) * 100 ) + 400;\n\n    setTimeout( () => this.activeTransitions--, this.durations[ type ] ); \n\n  }\n\n  title( show ) {\n\n    this.activeTransitions++;\n\n    const title = this.game.dom.texts.title;\n\n    if ( title.querySelector( 'span i' ) === null )\n      title.querySelectorAll( 'span' ).forEach( span => this.splitLetters( span ) );\n\n    const letters = title.querySelectorAll( 'i' );\n\n    this.flipLetters( 'title', letters, show );\n\n    title.style.opacity = 1;\n\n    const note = this.game.dom.texts.note;\n\n    this.tweens.title[ letters.length ] = new Tween( {\n      target: note.style,\n      easing: Easing.Sine.InOut(),\n      duration: show ? 800 : 400,\n      yoyo: show ? true : null,\n      from: { opacity: show ? 0 : ( parseFloat( getComputedStyle( note ).opacity ) ) },\n      to: { opacity: show ? 1 : 0 },\n    } );\n\n    setTimeout( () => this.activeTransitions--, this.durations.title );\n\n  }\n\n  timer( show ) {\n\n    this.activeTransitions++;\n\n    const timer = this.game.dom.texts.timer;\n\n    timer.style.opacity = 0;\n    this.game.timer.convert();\n    this.game.timer.setText();\n\n    this.splitLetters( timer );\n    const letters = timer.querySelectorAll( 'i' );\n    this.flipLetters( 'timer', letters, show );\n\n    timer.style.opacity = 1;\n\n    setTimeout( () => this.activeTransitions--, this.durations.timer );\n\n  }\n\n  splitLetters( element ) {\n\n    const text = element.innerHTML;\n\n    element.innerHTML = '';\n\n    text.split( '' ).forEach( letter => {\n\n      const i = document.createElement( 'i' );\n\n      i.innerHTML = letter;\n\n      element.appendChild( i );\n\n    } );\n\n  }\n\n  flipLetters( type, letters, show ) {\n\n    try { this.tweens[ type ].forEach( tween => tween.stop() ); } catch(e) {}\n    letters.forEach( ( letter, index ) => {\n\n      letter.style.opacity = show ? 0 : 1;\n\n      this.tweens[ type ][ index ] = new Tween( {\n        easing: Easing.Sine.Out(),\n        duration: show ? 800 : 400,\n        delay: index * 50,\n        onUpdate: tween => {\n\n          const rotation = show ? ( 1 - tween.value ) * -80 : tween.value * 80;\n\n          letter.style.transform = `rotate3d(0, 1, 0, ${rotation}deg)`;\n          letter.style.opacity = show ? tween.value : ( 1 - tween.value );\n\n        },\n      } );\n\n    } );\n\n    this.durations[ type ] = ( letters.length - 1 ) * 50 + ( show ? 800 : 400 );\n\n  }\n\n}\n\nclass Timer extends Animation {\n\n  constructor( game ) {\n\n    super( false );\n\n    this.game = game;\n    this.reset();\n    \n  }\n\n  start( continueGame ) {\n\n    this.startTime = continueGame ? ( Date.now() - this.deltaTime ) : Date.now();\n    this.deltaTime = 0;\n    this.converted = this.convert();\n\n    super.start();\n\n  }\n\n  reset() {\n\n    this.startTime = 0;\n    this.currentTime = 0;\n    this.deltaTime = 0;\n    this.converted = '0:00';\n\n  }\n\n  stop() {\n\n    this.currentTime = Date.now();\n    this.deltaTime = this.currentTime - this.startTime;\n    this.convert();\n\n    super.stop();\n\n    return { time: this.converted, millis: this.deltaTime };\n\n  }\n\n  update() {\n\n    const old = this.converted;\n\n    this.currentTime = Date.now();\n    this.deltaTime = this.currentTime - this.startTime;\n    this.convert();\n\n    if ( this.converted != old ) {\n\n      localStorage.setItem( 'theCube_time', this.deltaTime );\n      this.setText();\n\n    }\n\n  }\n\n  convert() {\n\n    const seconds = parseInt( ( this.deltaTime / 1000 ) % 60 );\n    const minutes = parseInt( ( this.deltaTime / ( 1000 * 60 ) ) );\n\n    this.converted = minutes + ':' + ( seconds < 10 ? '0' : '' ) + seconds;\n\n  }\n\n  setText() {\n\n    this.game.dom.texts.timer.innerHTML = this.converted;\n\n  }\n\n}\n\nconst RangeHTML = [\n\n  '<div class=\"range\">',\n    '<div class=\"range__label\"></div>',\n    '<div class=\"range__track\">',\n      '<div class=\"range__track-line\"></div>',\n      '<div class=\"range__handle\"><div></div></div>',\n    '</div>',\n    '<div class=\"range__list\"></div>',\n  '</div>',\n\n].join( '\\n' );\n\ndocument.querySelectorAll( 'range' ).forEach( el => {\n\n  const temp = document.createElement( 'div' );\n  temp.innerHTML = RangeHTML;\n\n  const range = temp.querySelector( '.range' );\n  const rangeLabel = range.querySelector( '.range__label' );\n  const rangeList = range.querySelector( '.range__list' );\n\n  range.setAttribute( 'name', el.getAttribute( 'name' ) );\n  rangeLabel.innerHTML = el.getAttribute( 'title' );\n\n  if ( el.hasAttribute( 'color' ) ) {\n\n    range.classList.add( 'range--type-color' );\n    range.classList.add( 'range--color-' + el.getAttribute( 'name' ) );\n\n  }\n\n  if ( el.hasAttribute( 'list' ) ) {\n\n    el.getAttribute( 'list' ).split( ',' ).forEach( listItemText => {\n\n      const listItem = document.createElement( 'div' );\n      listItem.innerHTML = listItemText;\n      rangeList.appendChild( listItem );\n\n    } );\n\n  }\n\n  el.parentNode.replaceChild( range, el );\n\n} );\n\nclass Range {\n\n  constructor( name, options ) {\n\n    options = Object.assign( {\n      range: [ 0, 1 ],\n      value: 0,\n      step: 0,\n      onUpdate: () => {},\n      onComplete: () => {},\n    }, options || {} );\n\n    this.element = document.querySelector( '.range[name=\"' + name + '\"]' );\n    this.track = this.element.querySelector( '.range__track' );\n    this.handle = this.element.querySelector( '.range__handle' );\n    this.list = [].slice.call( this.element.querySelectorAll( '.range__list div' ) );\n\n    this.value = options.value;\n    this.min = options.range[0];\n    this.max = options.range[1];\n    this.step = options.step;\n\n    this.onUpdate = options.onUpdate;\n    this.onComplete = options.onComplete;\n\n    this.setValue( this.value );\n\n    this.initDraggable();\n\n  }\n\n  setValue( value ) {\n\n    this.value = this.round( this.limitValue( value ) );\n    this.setHandlePosition();\n\n  }\n\n  initDraggable() {\n\n    let current;\n\n    this.draggable = new Draggable( this.handle, { calcDelta: true } );\n\n    this.draggable.onDragStart = position => {\n\n      current = this.positionFromValue( this.value );\n      this.handle.style.left = current + 'px';\n\n    };\n\n    this.draggable.onDragMove = position => {\n\n      current = this.limitPosition( current + position.delta.x );\n      this.value = this.round( this.valueFromPosition( current ) );\n      this.setHandlePosition();\n      \n      this.onUpdate( this.value );\n\n    };\n\n    this.draggable.onDragEnd = position => {\n\n      this.onComplete( this.value );\n\n    };\n\n  }\n\n  round( value ) {\n\n    if ( this.step < 1 ) return value;\n\n    return Math.round( ( value - this.min ) / this.step ) * this.step + this.min;\n\n  }\n\n  limitValue( value ) {\n\n    const max = Math.max( this.max, this.min );\n    const min = Math.min( this.max, this.min );\n\n    return Math.min( Math.max( value, min ), max );\n\n  }\n\n  limitPosition( position ) {\n\n    return Math.min( Math.max( position, 0 ), this.track.offsetWidth );\n\n  }\n\n  percentsFromValue( value ) {\n\n    return ( value - this.min ) / ( this.max - this.min );\n\n  }\n\n  valueFromPosition( position ) {\n\n    return this.min + ( this.max - this.min ) * ( position / this.track.offsetWidth );\n\n  }\n\n  positionFromValue( value ) {\n\n    return this.percentsFromValue( value ) * this.track.offsetWidth;\n\n  }\n\n  setHandlePosition() {\n\n    this.handle.style.left = this.percentsFromValue( this.value ) * 100 + '%';\n\n  }\n\n}\n\nclass Preferences {\n\n  constructor( game ) {\n\n    this.game = game;\n\n  }\n\n  init() {\n\n    this.ranges = {\n\n      size: new Range( 'size', {\n        value: this.game.cube.size,\n        range: [ 2, 5 ],\n        step: 1,\n        onUpdate: value => {\n\n          this.game.cube.size = value;\n\n          this.game.preferences.ranges.scramble.list.forEach( ( item, i ) => {\n\n            item.innerHTML = this.game.scrambler.scrambleLength[ this.game.cube.size ][ i ];\n\n          } );\n\n        },\n        onComplete: () => this.game.storage.savePreferences(),\n      } ),\n\n      flip: new Range( 'flip', {\n        value: this.game.controls.flipConfig,\n        range: [ 0, 2 ],\n        step: 1,\n        onUpdate: value => {\n\n          this.game.controls.flipConfig = value;\n\n        },\n        onComplete: () => this.game.storage.savePreferences(),\n      } ),\n\n      scramble: new Range( 'scramble', {\n        value: this.game.scrambler.dificulty,\n        range: [ 0, 2 ],\n        step: 1,\n        onUpdate: value => {\n\n          this.game.scrambler.dificulty = value;\n\n        },\n        onComplete: () => this.game.storage.savePreferences()\n      } ),\n\n      fov: new Range( 'fov', {\n        value: this.game.world.fov,\n        range: [ 2, 45 ],\n        onUpdate: value => {\n\n          this.game.world.fov = value;\n          this.game.world.resize();\n\n        },\n        onComplete: () => this.game.storage.savePreferences()\n      } ),\n\n      theme: new Range( 'theme', {\n        value: { cube: 0, erno: 1, dust: 2, camo: 3, rain: 4 }[ this.game.themes.theme ],\n        range: [ 0, 4 ],\n        step: 1,\n        onUpdate: value => {\n\n          const theme = [ 'cube', 'erno', 'dust', 'camo', 'rain' ][ value ];\n          this.game.themes.setTheme( theme );\n\n        },\n        onComplete: () => this.game.storage.savePreferences()\n      } ),\n\n      hue: new Range( 'hue', {\n        value: 0,\n        range: [ 0, 360 ],\n        onUpdate: value => this.game.themeEditor.updateHSL(),\n        onComplete: () => this.game.storage.savePreferences(),\n      } ),\n\n      saturation: new Range( 'saturation', {\n        value: 100,\n        range: [ 0, 100 ],\n        onUpdate: value => this.game.themeEditor.updateHSL(),\n        onComplete: () => this.game.storage.savePreferences(),\n      } ),\n\n      lightness: new Range( 'lightness', {\n        value: 50,\n        range: [ 0, 100 ],\n        onUpdate: value => this.game.themeEditor.updateHSL(),\n        onComplete: () => this.game.storage.savePreferences(),\n      } ),\n\n    };\n\n    this.ranges.scramble.list.forEach( ( item, i ) => {\n\n      item.innerHTML = this.game.scrambler.scrambleLength[ this.game.cube.size ][ i ];\n\n    } );\n    \n  }\n\n}\n\nclass Confetti {\n\n  constructor( game ) {\n\n    this.game = game;\n    this.started = 0;\n\n    this.options = {\n      speed: { min: 0.0011, max: 0.0022 },\n      revolution: { min: 0.01, max: 0.05 },\n      size: { min: 0.1, max: 0.15 },\n      colors: [ 0x41aac8, 0x82ca38, 0xffef48, 0xef3923, 0xff8c0a ],\n    };\n\n    this.geometry = new THREE.PlaneGeometry( 1, 1 );\n    this.material = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );\n\n    this.holders = [\n      new ConfettiStage( this.game, this, 1, 20 ),\n      new ConfettiStage( this.game, this, -1, 30 ),\n    ];\n\n  }\n\n  start() {\n\n    if ( this.started > 0 ) return;\n\n    this.holders.forEach( holder => {\n\n      this.game.world.scene.add( holder.holder );\n      holder.start();\n      this.started ++;\n\n    } );\n\n  }\n\n  stop() {\n\n    if ( this.started == 0 ) return;\n\n    this.holders.forEach( holder => {\n\n      holder.stop( () => {\n\n        this.game.world.scene.remove( holder.holder );\n        this.started --;\n\n      } );\n\n    } );\n\n  }\n\n  updateColors( colors ) {\n\n    this.holders.forEach( holder => {\n\n      holder.options.colors.forEach( ( color, index ) => {\n\n        holder.options.colors[ index ] = colors[ [ 'D', 'F', 'R', 'B', 'L' ][ index ] ];\n\n      } );\n\n    } );\n\n  }\n\n}\n\nclass ConfettiStage extends Animation {\n\n  constructor( game, parent, distance, count ) {\n\n    super( false );\n\n    this.game = game;\n    this.parent = parent;\n\n    this.distanceFromCube = distance;\n\n    this.count = count;\n    this.particles = [];\n\n    this.holder = new THREE.Object3D();\n    this.holder.rotation.copy( this.game.world.camera.rotation );\n\n    this.object = new THREE.Object3D();\n    this.holder.add( this.object );\n\n    this.resizeViewport = this.resizeViewport.bind( this );\n    this.game.world.onResize.push( this.resizeViewport );\n    this.resizeViewport();    \n\n    this.geometry = this.parent.geometry;\n    this.material = this.parent.material;\n\n    this.options = this.parent.options;\n\n    let i = this.count;\n    while ( i-- ) this.particles.push( new Particle( this ) );\n\n  }\n\n  start() {\n\n    this.time = performance.now();\n    this.playing = true;\n\n    let i = this.count;\n    while ( i-- ) this.particles[ i ].reset();\n\n    super.start();\n\n  }\n\n  stop( callback ) {\n\n    this.playing = false;\n    this.completed = 0;\n    this.callback = callback;\n\n  }\n\n  reset() {\n\n    super.stop();\n\n    this.callback();\n\n  }\n\n  update() {\n\n    const now = performance.now();\n    const delta = now - this.time;\n    this.time = now;\n\n    let i = this.count;\n\n    while ( i-- )\n      if ( ! this.particles[ i ].completed ) this.particles[ i ].update( delta );\n\n    if ( ! this.playing && this.completed == this.count ) this.reset();\n\n  }\n\n  resizeViewport() {\n\n    const fovRad = this.game.world.camera.fov * THREE.Math.DEG2RAD;\n\n    this.height = 2 * Math.tan( fovRad / 2 ) * ( this.game.world.camera.position.length() - this.distanceFromCube );\n    this.width = this.height * this.game.world.camera.aspect;\n\n    const scale = 1 / this.game.transition.data.cameraZoom;\n\n    this.width *= scale;\n    this.height *= scale;\n\n    this.object.position.z = this.distanceFromCube;\n    this.object.position.y = this.height / 2;\n\n  }\n  \n}\n\nclass Particle {\n\n  constructor( confetti ) {\n\n    this.confetti = confetti;\n    this.options = this.confetti.options;\n\n    this.velocity = new THREE.Vector3();\n    this.force = new THREE.Vector3();\n\n    this.mesh = new THREE.Mesh( this.confetti.geometry, this.confetti.material.clone() );\n    this.confetti.object.add( this.mesh );\n\n    this.size = THREE.Math.randFloat( this.options.size.min, this.options.size.max );\n    this.mesh.scale.set( this.size, this.size, this.size );\n\n    return this;\n\n  }\n\n  reset( randomHeight = true ) {\n\n    this.completed = false;\n\n    this.color = new THREE.Color( this.options.colors[ Math.floor( Math.random() * this.options.colors.length ) ] );\n    this.mesh.material.color.set( this.color );\n\n    this.speed = THREE.Math.randFloat( this.options.speed.min, this.options.speed.max ) * - 1;\n    this.mesh.position.x = THREE.Math.randFloat( - this.confetti.width / 2, this.confetti.width / 2 );\n    this.mesh.position.y = ( randomHeight )\n      ? THREE.Math.randFloat( this.size, this.confetti.height + this.size )\n      : this.size;\n\n    this.revolutionSpeed = THREE.Math.randFloat( this.options.revolution.min, this.options.revolution.max );\n    this.revolutionAxis = [ 'x', 'y', 'z' ][ Math.floor( Math.random() * 3 ) ];\n    this.mesh.rotation.set( Math.random() * Math.PI / 3, Math.random() * Math.PI / 3, Math.random() * Math.PI / 3 );\n\n  }\n\n  stop() {\n\n    this.completed = true;\n    this.confetti.completed ++;\n\n  }\n\n  update( delta ) {\n\n    this.mesh.position.y += this.speed * delta;\n    this.mesh.rotation[ this.revolutionAxis ] += this.revolutionSpeed;\n\n    if ( this.mesh.position.y < - this.confetti.height - this.size )\n      ( this.confetti.playing ) ? this.reset( false ) : this.stop();\n\n  }\n\n}\n\nclass Scores {\n\n  constructor( game ) {\n\n    this.game = game;\n\n    this.data = {\n      2: {\n        scores: [],\n        solves: 0,\n        best: 0,\n        worst: 0,\n      },\n      3: {\n        scores: [],\n        solves: 0,\n        best: 0,\n        worst: 0,\n      },\n      4: {\n        scores: [],\n        solves: 0,\n        best: 0,\n        worst: 0,\n      },\n      5: {\n        scores: [],\n        solves: 0,\n        best: 0,\n        worst: 0,\n      }\n    };\n\n  }\n\n  addScore( time ) {\n\n    const data = this.data[ this.game.cube.sizeGenerated ];\n\n    data.scores.push( time );\n    data.solves++;\n\n    if ( data.scores.lenght > 100 ) data.scores.shift();\n\n    let bestTime = false;    \n\n    if ( time < data.best || data.best === 0 ) {\n\n      data.best = time;\n      bestTime = true;\n\n    }\n\n    if ( time > data.worst ) data.worst = time;\n\n    this.game.storage.saveScores();\n\n    return bestTime;\n\n  }\n\n  calcStats() {\n\n    const s = this.game.cube.sizeGenerated;\n    const data = this.data[ s ];\n\n    this.setStat( 'cube-size', `${s}<i>x</i>${s}<i>x</i>${s}` );\n    this.setStat( 'total-solves', data.solves );\n    this.setStat( 'best-time', this.convertTime( data.best ) );\n    this.setStat( 'worst-time', this.convertTime( data.worst ) );\n    this.setStat( 'average-5', this.getAverage( 5 ) );\n    this.setStat( 'average-12', this.getAverage( 12 ) );\n    this.setStat( 'average-25', this.getAverage( 25 ) );\n\n  }\n\n  setStat( name, value ) {\n\n    if ( value === 0 ) value = '-';\n\n    this.game.dom.stats.querySelector( `.stats[name=\"${name}\"] b` ).innerHTML = value;\n\n  }\n\n  getAverage( count ) {\n\n    const data = this.data[ this.game.cube.sizeGenerated ];\n\n    if ( data.scores.length < count ) return 0;\n\n    return this.convertTime( data.scores.slice( -count ).reduce( ( a, b ) => a + b, 0 ) / count );\n\n  }\n\n  convertTime( time ) {\n\n    if ( time <= 0 ) return 0;\n\n    const seconds = parseInt( ( time / 1000 ) % 60 );\n    const minutes = parseInt( ( time / ( 1000 * 60 ) ) );\n\n    return minutes + ':' + ( seconds < 10 ? '0' : '' ) + seconds;\n\n  }\n\n}\n\nclass Storage {\n\n  constructor( game ) {\n\n    this.game = game;\n\n    const userVersion = localStorage.getItem( 'theCube_version' );\n\n    if ( ! userVersion || userVersion !== window.gameVersion ) {\n\n      this.clearGame();\n      this.clearPreferences();\n      this.migrateScores();\n      localStorage.setItem( 'theCube_version', window.gameVersion );\n\n    }\n\n  }\n\n  init() {\n\n    this.loadPreferences();\n    this.loadScores();\n\n  }\n\n  loadGame() {\n\n    try {\n\n      const gameInProgress = localStorage.getItem( 'theCube_playing' ) === 'true';\n\n      if ( ! gameInProgress ) throw new Error();\n\n      const gameCubeData = JSON.parse( localStorage.getItem( 'theCube_savedState' ) );\n      const gameTime = parseInt( localStorage.getItem( 'theCube_time' ) );\n\n      if ( ! gameCubeData || gameTime === null ) throw new Error();\n      if ( gameCubeData.size !== this.game.cube.sizeGenerated ) throw new Error();\n\n      this.game.cube.loadFromData( gameCubeData );\n\n      this.game.timer.deltaTime = gameTime;\n\n      this.game.saved = true;\n\n    } catch( e ) {\n\n      this.game.saved = false;\n\n    }\n\n  }\n\n  saveGame() {\n\n    const gameInProgress = true;\n    const gameCubeData = { names: [], positions: [], rotations: [] };\n    const gameTime = this.game.timer.deltaTime;\n\n    gameCubeData.size = this.game.cube.sizeGenerated;\n\n    this.game.cube.pieces.forEach( piece => {\n\n      gameCubeData.names.push( piece.name );\n      gameCubeData.positions.push( piece.position );\n      gameCubeData.rotations.push( piece.rotation.toVector3() );\n\n    } );\n\n    localStorage.setItem( 'theCube_playing', gameInProgress );\n    localStorage.setItem( 'theCube_savedState', JSON.stringify( gameCubeData ) );\n    localStorage.setItem( 'theCube_time', gameTime );\n\n  }\n\n  clearGame() {\n\n    localStorage.removeItem( 'theCube_playing' );\n    localStorage.removeItem( 'theCube_savedState' );\n    localStorage.removeItem( 'theCube_time' );\n\n  }\n\n  loadScores() {\n\n    try {\n\n      const scoresData = JSON.parse( localStorage.getItem( 'theCube_scores' ) );\n\n      if ( ! scoresData ) throw new Error();\n\n      this.game.scores.data = scoresData;\n\n    } catch( e ) {}\n\n  }\n\n  saveScores() {\n\n    const scoresData = this.game.scores.data;\n\n    localStorage.setItem( 'theCube_scores', JSON.stringify( scoresData ) );\n\n  }\n\n  clearScores() {\n\n    localStorage.removeItem( 'theCube_scores' );\n\n  }\n\n  migrateScores() {\n\n    try {\n\n      const scoresData = JSON.parse( localStorage.getItem( 'theCube_scoresData' ) );\n      const scoresBest = parseInt( localStorage.getItem( 'theCube_scoresBest' ) );\n      const scoresWorst = parseInt( localStorage.getItem( 'theCube_scoresWorst' ) );\n      const scoresSolves = parseInt( localStorage.getItem( 'theCube_scoresSolves' ) );\n\n      if ( ! scoresData || ! scoresBest || ! scoresSolves || ! scoresWorst ) return false;\n\n      this.game.scores.data[ 3 ].scores = scoresData;\n      this.game.scores.data[ 3 ].best = scoresBest;\n      this.game.scores.data[ 3 ].solves = scoresSolves;\n      this.game.scores.data[ 3 ].worst = scoresWorst;\n\n      localStorage.removeItem( 'theCube_scoresData' );\n      localStorage.removeItem( 'theCube_scoresBest' );\n      localStorage.removeItem( 'theCube_scoresWorst' );\n      localStorage.removeItem( 'theCube_scoresSolves' );\n\n    } catch( e ) {}\n\n  }\n\n  loadPreferences() {\n\n    try {\n\n      const preferences = JSON.parse( localStorage.getItem( 'theCube_preferences' ) );\n\n      if ( ! preferences ) throw new Error();\n\n      this.game.cube.size = parseInt( preferences.cubeSize );\n      this.game.controls.flipConfig = parseInt( preferences.flipConfig );\n      this.game.scrambler.dificulty = parseInt( preferences.dificulty );\n\n      this.game.world.fov = parseFloat( preferences.fov );\n      this.game.world.resize();\n\n      this.game.themes.colors = preferences.colors;\n      this.game.themes.setTheme( preferences.theme );\n\n      return true;\n\n    } catch (e) {\n\n      this.game.cube.size = 3;\n      this.game.controls.flipConfig = 0;\n      this.game.scrambler.dificulty = 1;\n\n      this.game.world.fov = 10;\n      this.game.world.resize();\n\n      this.game.themes.setTheme( 'cube' );\n\n      this.savePreferences();\n\n      return false;\n\n    }\n\n  }\n\n  savePreferences() {\n\n    const preferences = {\n      cubeSize: this.game.cube.size,\n      flipConfig: this.game.controls.flipConfig,\n      dificulty: this.game.scrambler.dificulty,\n      fov: this.game.world.fov,\n      theme: this.game.themes.theme,\n      colors: this.game.themes.colors,\n    };\n\n    localStorage.setItem( 'theCube_preferences', JSON.stringify( preferences ) );\n\n  }\n\n  clearPreferences() {\n\n    localStorage.removeItem( 'theCube_preferences' );\n\n  }\n\n}\n\nclass Themes {\n\n  constructor( game ) {\n\n    this.game = game;\n    this.theme = null;\n\n    this.defaults = {\n      cube: {\n        U: 0xfff7ff, // white\n        D: 0xffef48, // yellow\n        F: 0xef3923, // red\n        R: 0x41aac8, // blue\n        B: 0xff8c0a, // orange\n        L: 0x82ca38, // green\n        P: 0x08101a, // piece\n        G: 0xd1d5db, // background\n      },\n      erno: {\n        U: 0xffffff,\n        D: 0xffd500,\n        F: 0xc41e3a,\n        R: 0x0051ba,\n        B: 0xff5800,\n        L: 0x009e60,\n        P: 0x08101a,\n        G: 0x8abdff,\n      },\n      dust: {\n        U: 0xfff6eb,\n        D: 0xe7c48d,\n        F: 0x8f253e,\n        R: 0x607e69,\n        B: 0xbe6f62,\n        L: 0x849f5d,\n        P: 0x08101a,\n        G: 0xE7C48D,\n      },\n      camo: {\n        U: 0xfff6eb,\n        D: 0xbfb672,\n        F: 0x37241c,\n        R: 0x718456,\n        B: 0x805831,\n        L: 0x37431d,\n        P: 0x08101a,\n        G: 0xBFB672,\n      },\n      rain: {\n        U: 0xfafaff,\n        D: 0xedb92d,\n        F: 0xce2135,\n        R: 0x449a89,\n        B: 0xec582f,\n        L: 0xa3a947,\n        P: 0x08101a,\n        G: 0x87b9ac,\n      },\n    };\n\n    this.colors = JSON.parse( JSON.stringify( this.defaults ) );\n\n  }\n\n  getColors() {\n\n    return this.colors[ this.theme ];\n\n  }\n\n  setTheme( theme = false, force = false ) {\n\n    if ( theme === this.theme && force === false ) return;\n    if ( theme !== false ) this.theme = theme;\n\n    const colors = this.getColors();\n\n    this.game.dom.prefs.querySelectorAll( '.range__handle div' ).forEach( range => {\n\n      range.style.background = '#' + colors.R.toString(16).padStart(6, '0');\n\n    } );\n\n    this.game.cube.updateColors( colors );\n\n    this.game.confetti.updateColors( colors );\n\n    this.game.dom.back.style.background = '#' + colors.G.toString(16).padStart(6, '0');\n\n  }\n\n}\n\nclass ThemeEditor {\n\n  constructor( game ) {\n\n    this.game = game;\n\n    this.editColor = 'R';\n\n    this.getPieceColor = this.getPieceColor.bind( this );\n\n  }\n\n  colorFromHSL( h, s, l ) {\n\n    h = Math.round( h );\n    s = Math.round( s );\n    l = Math.round( l );\n\n    return new THREE.Color( `hsl(${h}, ${s}%, ${l}%)` );\n\n  }\n\n  setHSL( color = null, animate = false ) {\n\n    this.editColor = ( color === null) ? 'R' : color;\n\n    const hsl = new THREE.Color( this.game.themes.getColors()[ this.editColor ] );\n\n    const { h, s, l } = hsl.getHSL( hsl );\n    const { hue, saturation, lightness } = this.game.preferences.ranges;\n\n    if ( animate ) {\n\n      const ho = hue.value / 360;\n      const so = saturation.value / 100;\n      const lo = lightness.value / 100;\n\n      const colorOld = this.colorFromHSL( hue.value, saturation.value, lightness.value );\n\n      if ( this.tweenHSL ) this.tweenHSL.stop();\n\n      this.tweenHSL = new Tween( {\n        duration: 200,\n        easing: Easing.Sine.Out(),\n        onUpdate: tween => {\n\n          hue.setValue( ( ho + ( h - ho ) * tween.value ) * 360 );\n          saturation.setValue( ( so + ( s - so ) * tween.value ) * 100 );\n          lightness.setValue( ( lo + ( l - lo ) * tween.value ) * 100 );\n\n          const colorTween = colorOld.clone().lerp( hsl, tween.value );\n\n          const colorTweenStyle = colorTween.getStyle();\n          const colorTweenHex = colorTween.getHSL( colorTween );\n\n          hue.handle.style.color = colorTweenStyle;\n          saturation.handle.style.color = colorTweenStyle;\n          lightness.handle.style.color = colorTweenStyle;\n\n          saturation.track.style.color =\n            this.colorFromHSL( colorTweenHex.h * 360, 100, 50 ).getStyle();\n          lightness.track.style.color =\n            this.colorFromHSL( colorTweenHex.h * 360, colorTweenHex.s * 100, 50 ).getStyle();\n\n          this.game.dom.theme.style.display = 'none';\n          this.game.dom.theme.offsetHeight;\n          this.game.dom.theme.style.display = '';\n\n        },\n        onComplete: () => {\n\n          this.updateHSL();\n          this.game.storage.savePreferences();\n\n        },\n      } );\n\n    } else {\n\n      hue.setValue( h * 360 );\n      saturation.setValue( s * 100 );\n      lightness.setValue( l * 100 );\n\n      this.updateHSL();\n      this.game.storage.savePreferences();\n\n    }\n\n  }\n\n  updateHSL() {\n\n    const { hue, saturation, lightness } = this.game.preferences.ranges;\n\n    const h = hue.value;\n    const s = saturation.value;\n    const l = lightness.value;\n\n    const color = this.colorFromHSL( h, s, l ).getStyle();\n\n    hue.handle.style.color = color;\n    saturation.handle.style.color = color;\n    lightness.handle.style.color = color;\n\n    saturation.track.style.color = this.colorFromHSL( h, 100, 50 ).getStyle();\n    lightness.track.style.color = this.colorFromHSL( h, s, 50 ).getStyle();\n\n    this.game.dom.theme.style.display = 'none';\n    this.game.dom.theme.offsetHeight;\n    this.game.dom.theme.style.display = '';\n\n    const theme = this.game.themes.theme;\n\n    this.game.themes.colors[ theme ][ this.editColor ] = this.colorFromHSL( h, s, l ).getHex();\n    this.game.themes.setTheme();\n\n  }\n\n  colorPicker( enable ) {\n\n    if ( enable ) {\n\n      this.game.dom.game.addEventListener( 'click', this.getPieceColor, false );\n\n    } else {\n\n      this.game.dom.game.removeEventListener( 'click', this.getPieceColor, false );\n\n    }\n\n  }\n\n  getPieceColor( event ) {\n\n    const clickEvent = event.touches\n      ? ( event.touches[ 0 ] || event.changedTouches[ 0 ] )\n      : event;\n\n    const clickPosition = new THREE.Vector2( clickEvent.pageX, clickEvent.pageY );\n\n    let edgeIntersect = this.game.controls.getIntersect( clickPosition, this.game.cube.edges, true );\n    let pieceIntersect = this.game.controls.getIntersect( clickPosition, this.game.cube.cubes, true );\n\n    if ( edgeIntersect !== false ) {\n\n      const edge = edgeIntersect.object;\n\n      const position = edge.parent\n        .localToWorld( edge.position.clone() )\n        .sub( this.game.cube.object.position )\n        .sub( this.game.cube.animator.position );\n\n      const mainAxis = this.game.controls.getMainAxis( position );\n      if ( position.multiplyScalar( 2 ).round()[ mainAxis ] < 1 ) edgeIntersect = false;\n\n    }\n\n    const name = edgeIntersect ? edgeIntersect.object.name : pieceIntersect ? 'P' : 'G';\n\n    this.setHSL( name, true );\n\n  }\n\n  resetTheme() {\n\n    this.game.themes.colors[ this.game.themes.theme ] =\n      JSON.parse( JSON.stringify( this.game.themes.defaults[ this.game.themes.theme ] ) );\n\n    this.game.themes.setTheme();\n\n    this.setHSL( this.editColor, true );\n\n  }\n\n}\n\nconst States = {\n  3: {\n    checkerboard: {\n      names: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26 ],\n      positions: [\n        { \"x\": 1/3, \"y\": -1/3, \"z\": 1/3 },\n        { \"x\": -1/3, \"y\": 1/3, \"z\": 0 },\n        { \"x\": 1/3, \"y\": -1/3, \"z\": -1/3 },\n        { \"x\": -1/3, \"y\": 0, \"z\": -1/3 },\n        { \"x\": 1/3, \"y\": 0, \"z\": 0 },\n        { \"x\": -1/3, \"y\": 0, \"z\": 1/3 },\n        { \"x\": 1/3, \"y\": 1/3, \"z\": 1/3 },\n        { \"x\": -1/3, \"y\": -1/3, \"z\": 0 },\n        { \"x\": 1/3, \"y\": 1/3, \"z\": -1/3 },\n        { \"x\": 0, \"y\": 1/3, \"z\": -1/3 },\n        { \"x\": 0, \"y\": -1/3, \"z\": 0 },\n        { \"x\": 0, \"y\": 1/3, \"z\": 1/3 },\n        { \"x\": 0, \"y\": 0, \"z\": 1/3 },\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\n        { \"x\": 0, \"y\": 0, \"z\": -1/3 },\n        { \"x\": 0, \"y\": -1/3, \"z\": -1/3 },\n        { \"x\": 0, \"y\": 1/3, \"z\": 0 },\n        { \"x\": 0, \"y\": -1/3, \"z\": 1/3 },\n        { \"x\": -1/3, \"y\": -1/3, \"z\": 1/3 },\n        { \"x\": 1/3, \"y\": 1/3, \"z\": 0 },\n        { \"x\": -1/3, \"y\": -1/3, \"z\": -1/3 },\n        { \"x\": 1/3, \"y\": 0, \"z\": -1/3 },\n        { \"x\": -1/3, \"y\": 0, \"z\": 0 },\n        { \"x\": 1/3, \"y\": 0, \"z\": 1/3 },\n        { \"x\": -1/3, \"y\": 1/3, \"z\": 1/3 },\n        { \"x\": 1/3, \"y\": -1/3, \"z\": 0 },\n        { \"x\": -1/3, \"y\": 1/3, \"z\": -1/3 }\n      ],\n      rotations: [\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI, },\n        { \"x\": Math.PI, \"y\": 0, \"z\": 0 },\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI },\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI },\n        { \"x\": Math.PI, \"y\": 0, \"z\": 0 },\n        { \"x\": -Math.PI, \"y\": 0, \"z\": Math.PI },\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\n        { \"x\": -Math.PI, \"y\": 0, \"z\": 0 },\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\n        { \"x\": Math.PI, \"y\": 0, \"z\": 0 },\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\n        { \"x\": -Math.PI, \"y\": 0, \"z\": 0 },\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\n        { \"x\": 0, \"y\": 0, \"z\": Math.PI },\n        { \"x\": 0, \"y\": 0, \"z\": 0 },\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI },\n        { \"x\": -Math.PI, \"y\": 0, \"z\": 0 },\n        { \"x\": Math.PI, \"y\": 0, \"z\": Math.PI }\n      ],\n      size: 3,\n    },\n  }\n};\n\nclass IconsConverter {\n\n  constructor( options ) {\n\n    options = Object.assign( {\n      tagName: 'icon',\n      className: 'icon',\n      styles: false,\n      icons: {},\n      observe: false,\n      convert: false,\n    }, options || {} );\n\n    this.tagName = options.tagName;\n    this.className = options.className;\n    this.icons = options.icons;\n\n    this.svgTag = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );\n    this.svgTag.setAttribute( 'class', this.className );\n\n    if ( options.styles ) this.addStyles();\n    if ( options.convert ) this.convertAllIcons();\n\n    if ( options.observe ) {\n\n      const MutationObserver = window.MutationObserver || window.WebKitMutationObserver;\n      this.observer = new MutationObserver( mutations => { this.convertAllIcons(); } );\n      this.observer.observe( document.documentElement, { childList: true, subtree: true } );\n\n    }\n\n    return this;\n\n  }\n\n  convertAllIcons() {\n\n    document.querySelectorAll( this.tagName ).forEach( icon => { this.convertIcon( icon ); } );\n\n  }\n\n  convertIcon( icon ) {\n\n    const svgData = this.icons[ icon.attributes[0].localName ];\n\n    if ( typeof svgData === 'undefined' ) return;\n\n    const svg = this.svgTag.cloneNode( true );\n    const viewBox = svgData.viewbox.split( ' ' );\n\n    svg.setAttributeNS( null, 'viewBox', svgData.viewbox );\n    svg.style.width = viewBox[2] / viewBox[3] + 'em';\n    svg.style.height = '1em';\n    svg.innerHTML = svgData.content;\n\n    icon.parentNode.replaceChild( svg, icon );\n\n  }\n\n  addStyles() {\n\n    const style = document.createElement( 'style' );\n    style.innerHTML = `.${this.className} { display: inline-block; font-size: inherit; overflow: visible; vertical-align: -0.125em; preserveAspectRatio: none; }`;\n    document.head.appendChild( style );\n\n  }\n\n}\n\nconst Icons = new IconsConverter( {\n\n  icons: {\n    settings: {\n      viewbox: '0 0 512 512',\n      content: '<path fill=\"currentColor\" d=\"M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z\" />',\n    },\n    back: {\n      viewbox: '0 0 512 512',\n      content: '<path transform=\"translate(512, 0) scale(-1,1)\" fill=\"currentColor\" d=\"M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z\" />',\n    },\n    trophy: {\n      viewbox: '0 0 576 512',\n      content: '<path fill=\"currentColor\" d=\"M552 64H448V24c0-13.3-10.7-24-24-24H152c-13.3 0-24 10.7-24 24v40H24C10.7 64 0 74.7 0 88v56c0 66.5 77.9 131.7 171.9 142.4C203.3 338.5 240 360 240 360v72h-48c-35.3 0-64 20.7-64 56v12c0 6.6 5.4 12 12 12h296c6.6 0 12-5.4 12-12v-12c0-35.3-28.7-56-64-56h-48v-72s36.7-21.5 68.1-73.6C498.4 275.6 576 210.3 576 144V88c0-13.3-10.7-24-24-24zM64 144v-16h64.2c1 32.6 5.8 61.2 12.8 86.2-47.5-16.4-77-49.9-77-70.2zm448 0c0 20.2-29.4 53.8-77 70.2 7-25 11.8-53.6 12.8-86.2H512v16zm-127.3 4.7l-39.6 38.6 9.4 54.6c1.7 9.8-8.7 17.2-17.4 12.6l-49-25.8-49 25.8c-8.8 4.6-19.1-2.9-17.4-12.6l9.4-54.6-39.6-38.6c-7.1-6.9-3.2-19 6.7-20.5l54.8-8 24.5-49.6c4.4-8.9 17.1-8.9 21.5 0l24.5 49.6 54.8 8c9.6 1.5 13.5 13.6 6.4 20.5z\" />',\n    },\n    cancel: {\n      viewbox: '0 0 352 512',\n      content: '<path fill=\"currentColor\" d=\"M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z\" />',\n    },\n    theme: {\n      viewbox: '0 0 512 512',\n      content: '<path fill=\"currentColor\" d=\"M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z\"/>',\n    },\n    reset: {\n      viewbox: '0 0 512 512',\n      content: '<path fill=\"currentColor\" d=\"M370.72 133.28C339.458 104.008 298.888 87.962 255.848 88c-77.458.068-144.328 53.178-162.791 126.85-1.344 5.363-6.122 9.15-11.651 9.15H24.103c-7.498 0-13.194-6.807-11.807-14.176C33.933 94.924 134.813 8 256 8c66.448 0 126.791 26.136 171.315 68.685L463.03 40.97C478.149 25.851 504 36.559 504 57.941V192c0 13.255-10.745 24-24 24H345.941c-21.382 0-32.09-25.851-16.971-40.971l41.75-41.749zM32 296h134.059c21.382 0 32.09 25.851 16.971 40.971l-41.75 41.75c31.262 29.273 71.835 45.319 114.876 45.28 77.418-.07 144.315-53.144 162.787-126.849 1.344-5.363 6.122-9.15 11.651-9.15h57.304c7.498 0 13.194 6.807 11.807 14.176C478.067 417.076 377.187 504 256 504c-66.448 0-126.791-26.136-171.315-68.685L48.97 471.03C33.851 486.149 8 475.441 8 454.059V320c0-13.255 10.745-24 24-24z\" />',\n    },\n    trash: {\n      viewbox: '0 0 448 512',\n      content: '<path fill=\"currentColor\" d=\"M432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16zM53.2 467a48 48 0 0 0 47.9 45h245.8a48 48 0 0 0 47.9-45L416 128H32z\" />',\n    },\n  },\n\n  convert: true,\n\n} );\n\nconst STATE = {\n  Menu: 0,\n  Playing: 1,\n  Complete: 2,\n  Stats: 3,\n  Prefs: 4,\n  Theme: 5,\n};\n\nconst BUTTONS = {\n  Menu: [ 'stats', 'prefs' ],\n  Playing: [ 'back' ],\n  Complete: [],\n  Stats: [],\n  Prefs: [ 'back', 'theme' ],\n  Theme: [ 'back', 'reset' ],\n  None: [],\n};\n\nconst SHOW = true;\nconst HIDE = false;\n\nclass Game {\n\n  constructor() {\n\n    this.dom = {\n      ui: document.querySelector( '.ui' ),\n      game: document.querySelector( '.ui__game' ),\n      back: document.querySelector( '.ui__background' ),\n      prefs: document.querySelector( '.ui__prefs' ),\n      theme: document.querySelector( '.ui__theme' ),\n      stats: document.querySelector( '.ui__stats' ),\n      texts: {\n        title: document.querySelector( '.text--title' ),\n        note: document.querySelector( '.text--note' ),\n        timer: document.querySelector( '.text--timer' ),\n        complete: document.querySelector( '.text--complete' ),\n        best: document.querySelector( '.text--best-time' ),\n        theme: document.querySelector( '.text--theme' ),\n      },\n      buttons: {\n        prefs: document.querySelector( '.btn--prefs' ),\n        back: document.querySelector( '.btn--back' ),\n        stats: document.querySelector( '.btn--stats' ),\n        reset: document.querySelector( '.btn--reset' ),\n        theme: document.querySelector( '.btn--theme' ),\n      },\n    };\n\n    this.world = new World( this );\n    this.cube = new Cube( this );\n    this.controls = new Controls( this );\n    this.scrambler = new Scrambler( this );\n    this.transition = new Transition( this );\n    this.timer = new Timer( this );\n    this.preferences = new Preferences( this );\n    this.scores = new Scores( this );\n    this.storage = new Storage( this );\n    this.confetti = new Confetti( this );\n    this.themes = new Themes( this );\n    this.themeEditor = new ThemeEditor( this );\n\n    this.initActions();\n\n    this.state = STATE.Menu;\n    this.newGame = false;\n    this.saved = false;\n\n    this.storage.init();\n    this.preferences.init();\n    this.cube.init();\n    this.transition.init();\n\n    this.storage.loadGame();\n    this.scores.calcStats();\n\n    setTimeout( () => {\n\n      this.transition.float();\n      this.transition.cube( SHOW );\n\n      setTimeout( () => this.transition.title( SHOW ), 700 );\n      setTimeout( () => this.transition.buttons( BUTTONS.Menu, BUTTONS.None ), 1000 );\n\n    }, 500 );\n\n  }\n\n  initActions() {\n\n    let tappedTwice = false;\n\n    this.dom.game.addEventListener( 'click', event => {\n\n      if ( this.transition.activeTransitions > 0 ) return;\n      if ( this.state === STATE.Playing ) return;\n\n      if ( this.state === STATE.Menu ) {\n\n        if ( ! tappedTwice ) {\n\n          tappedTwice = true;\n          setTimeout( () => tappedTwice = false, 300 );\n          return false;\n\n        }\n\n        this.game( SHOW );\n\n      } else if ( this.state === STATE.Complete ) {\n\n        this.complete( HIDE );\n\n      } else if ( this.state === STATE.Stats ) {\n\n        this.stats( HIDE );\n\n      } \n\n    }, false );\n\n    this.controls.onMove = () => {\n\n      if ( this.newGame ) {\n        \n        this.timer.start( true );\n        this.newGame = false;\n\n      }\n\n    };\n\n    this.dom.buttons.back.onclick = event => {\n\n      if ( this.transition.activeTransitions > 0 ) return;\n\n      if ( this.state === STATE.Playing ) {\n\n        this.game( HIDE );\n\n      } else if ( this.state === STATE.Prefs ) {\n\n        this.prefs( HIDE );\n\n      } else if ( this.state === STATE.Theme ) {\n\n        this.theme( HIDE );\n\n      }\n\n    };\n\n    this.dom.buttons.reset.onclick = event => {\n\n      if ( this.state === STATE.Theme ) {\n\n        this.themeEditor.resetTheme();\n\n      }\n      \n    };\n\n    this.dom.buttons.prefs.onclick = event => this.prefs( SHOW );\n\n    this.dom.buttons.theme.onclick = event => this.theme( SHOW );\n\n    this.dom.buttons.stats.onclick = event => this.stats( SHOW );\n\n    this.controls.onSolved = () => this.complete( SHOW );\n\n  }\n\n  game( show ) {\n\n    if ( show ) {\n\n      if ( ! this.saved ) {\n\n        this.scrambler.scramble();\n        this.controls.scrambleCube();\n        this.newGame = true;\n\n      }\n\n      const duration = this.saved ? 0 :\n        this.scrambler.converted.length * ( this.controls.flipSpeeds[0] + 10 );\n\n      this.state = STATE.Playing;\n      this.saved = true;\n\n      this.transition.buttons( BUTTONS.None, BUTTONS.Menu );\n\n      this.transition.zoom( STATE.Playing, duration );\n      this.transition.title( HIDE );\n\n      setTimeout( () => {\n\n        this.transition.timer( SHOW );\n        this.transition.buttons( BUTTONS.Playing, BUTTONS.None );\n\n      }, this.transition.durations.zoom - 1000 );\n\n      setTimeout( () => {\n\n        this.controls.enable();\n        if ( ! this.newGame ) this.timer.start( true );\n\n      }, this.transition.durations.zoom );\n\n    } else {\n\n      this.state = STATE.Menu;\n\n      this.transition.buttons( BUTTONS.Menu, BUTTONS.Playing );\n\n      this.transition.zoom( STATE.Menu, 0 );\n\n      this.controls.disable();\n      if ( ! this.newGame ) this.timer.stop();\n      this.transition.timer( HIDE );\n\n      setTimeout( () => this.transition.title( SHOW ), this.transition.durations.zoom - 1000 );\n\n      this.playing = false;\n      this.controls.disable();\n\n    }\n\n  }\n\n  prefs( show ) {\n\n    if ( show ) {\n\n      if ( this.transition.activeTransitions > 0 ) return;\n\n      this.state = STATE.Prefs;\n\n      this.transition.buttons( BUTTONS.Prefs, BUTTONS.Menu );\n\n      this.transition.title( HIDE );\n      this.transition.cube( HIDE );\n\n      setTimeout( () => this.transition.preferences( SHOW ), 1000 );\n\n    } else {\n\n      this.cube.resize();\n\n      this.state = STATE.Menu;\n\n      this.transition.buttons( BUTTONS.Menu, BUTTONS.Prefs );\n\n      this.transition.preferences( HIDE );\n\n      setTimeout( () => this.transition.cube( SHOW ), 500 );\n      setTimeout( () => this.transition.title( SHOW ), 1200 );\n\n    }\n\n  }\n\n  theme( show ) {\n\n    this.themeEditor.colorPicker( show );\n    \n    if ( show ) {\n\n      if ( this.transition.activeTransitions > 0 ) return;\n\n      this.cube.loadFromData( States[ '3' ][ 'checkerboard' ] );\n\n      this.themeEditor.setHSL( null, false );\n\n      this.state = STATE.Theme;\n\n      this.transition.buttons( BUTTONS.Theme, BUTTONS.Prefs );\n\n      this.transition.preferences( HIDE );\n\n      setTimeout( () => this.transition.cube( SHOW, true ), 500 );\n      setTimeout( () => this.transition.theming( SHOW ), 1000 );\n\n    } else {\n\n      this.state = STATE.Prefs;\n\n      this.transition.buttons( BUTTONS.Prefs, BUTTONS.Theme );\n\n      this.transition.cube( HIDE, true );\n      this.transition.theming( HIDE );\n\n      setTimeout( () => this.transition.preferences( SHOW ), 1000 );\n      setTimeout( () => {\n\n        const gameCubeData = JSON.parse( localStorage.getItem( 'theCube_savedState' ) );\n\n        if ( !gameCubeData ) {\n\n          this.cube.resize( true );\n          return;\n\n        }\n\n        this.cube.loadFromData( gameCubeData );\n\n      }, 1500 );\n\n    }\n\n  }\n\n  stats( show ) {\n\n    if ( show ) {\n\n      if ( this.transition.activeTransitions > 0 ) return;\n\n      this.state = STATE.Stats;\n\n      this.transition.buttons( BUTTONS.Stats, BUTTONS.Menu );\n\n      this.transition.title( HIDE );\n      this.transition.cube( HIDE );\n\n      setTimeout( () => this.transition.stats( SHOW ), 1000 );\n\n    } else {\n\n      this.state = STATE.Menu;\n\n      this.transition.buttons( BUTTONS.Menu, BUTTONS.None );\n\n      this.transition.stats( HIDE );\n\n      setTimeout( () => this.transition.cube( SHOW ), 500 );\n      setTimeout( () => this.transition.title( SHOW ), 1200 );\n\n    }\n\n  }\n\n  complete( show ) {\n\n    if ( show ) {\n\n      this.transition.buttons( BUTTONS.Complete, BUTTONS.Playing );\n\n      this.state = STATE.Complete;\n      this.saved = false;\n\n      this.controls.disable();\n      this.timer.stop();\n      this.storage.clearGame();\n\n      this.bestTime = this.scores.addScore( this.timer.deltaTime );\n\n      this.transition.zoom( STATE.Menu, 0 );\n      this.transition.elevate( SHOW );\n\n      setTimeout( () => {\n\n        this.transition.complete( SHOW, this.bestTime );\n        this.confetti.start();\n\n      }, 1000 );\n\n    } else {\n\n      this.state = STATE.Stats;\n      this.saved = false;\n\n      this.transition.timer( HIDE );\n      this.transition.complete( HIDE, this.bestTime );\n      this.transition.cube( HIDE );\n      this.timer.reset();\n\n      setTimeout( () => {\n\n        this.cube.reset();\n        this.confetti.stop();\n\n        this.transition.stats( SHOW );\n        this.transition.elevate( 0 );\n\n      }, 1000 );\n\n      return false;\n\n    }\n\n  }\n\n}\n\n// Game initialization handled by error recovery script\n\n// Error handling for Three.js loading\nlet initAttempts = 0;\nconst maxInitAttempts = 5;\nlet gameInitialized = false;\n\nfunction checkThreeJsLoaded() {\n  return typeof THREE !== 'undefined' && THREE.Scene;\n}\n\nfunction initializeGame() {\n  if (checkThreeJsLoaded() && document.querySelector('.ui') && !window.game) {\n    window.version = '0.99.2';\n    window.game = new Game();\n    gameInitialized = true;\n    console.log('Game initialized successfully');\n    return true;\n  }\n  return false;\n}\n\nfunction waitForThreeJs() {\n  const checkInterval = setInterval(function() {\n    if (checkThreeJsLoaded()) {\n      clearInterval(checkInterval);\n      setTimeout(function() {\n        initAttempts++;\n        if (!initializeGame() && initAttempts < maxInitAttempts) {\n          console.log('Retrying initialization...');\n          setTimeout(waitForThreeJs, 1000);\n        } else if (initAttempts >= maxInitAttempts) {\n          console.error('Failed to initialize game after ' + maxInitAttempts + ' attempts');\n          window.ReactNativeWebView?.postMessage(JSON.stringify({ type: 'error', message: 'Failed to initialize cube game' }));\n        }\n      }, 500);\n    } else {\n      console.log('Waiting for Three.js to load...');\n    }\n  }, 200);\n}\n\n// WebGL context loss handling\nconst canvas = document.querySelector('canvas');\nif (canvas) {\n  canvas.addEventListener('webglcontextlost', function(event) {\n    event.preventDefault();\n    console.warn('WebGL context lost. Attempting to restore...');\n    window.ReactNativeWebView?.postMessage(JSON.stringify({ type: 'warning', message: 'WebGL context lost' }));\n    gameInitialized = false;\n  }, false);\n  canvas.addEventListener('webglcontextrestored', function() {\n    console.log('WebGL context restored. Reinitializing game...');\n    window.ReactNativeWebView?.postMessage(JSON.stringify({ type: 'info', message: 'WebGL context restored' }));\n    initAttempts = 0;\n    waitForThreeJs();\n  }, false);\n}\n\n// Visibility API to pause/resume rendering\ndocument.addEventListener('visibilitychange', function() {\n  if (document.hidden) {\n    console.log('Page is hidden. Pausing game logic.');\n    window.ReactNativeWebView?.postMessage(JSON.stringify({ type: 'info', message: 'Page hidden, game paused' }));\n    if (window.game && window.game.world && window.game.world.stop) window.game.world.stop();\n  } else {\n    console.log('Page is visible. Resuming game logic.');\n    window.ReactNativeWebView?.postMessage(JSON.stringify({ type: 'info', message: 'Page visible, game resumed' }));\n    if (window.game && window.game.world && window.game.world.start) window.game.world.start();\n    else if (!gameInitialized) {\n      initAttempts = 0;\n      waitForThreeJs();\n    }\n  }\n});\n\n// Initial call\nsetTimeout(waitForThreeJs, 100);\n</script>\n</body>\n</html>";
};

export default getTheCubeHTML();




